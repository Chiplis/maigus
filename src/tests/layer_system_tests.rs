//! Comprehensive tests for the MTG layer system.
//!
//! These tests verify that continuous effects are applied in the correct layer order
//! as defined by MTG rule 613. Many of these tests are expected to fail until the
//! layer system is fully integrated into characteristic calculation.

use crate::ability::{Ability, AbilityKind};
use crate::card::{CardBuilder, PowerToughness};
use crate::cards::definitions::{
    blood_moon, crusade, dauthi_slayer, grizzly_bears, high_market, humility, manascape_refractor,
    marvin_murderous_mimic, mycosynth_lattice, rex_cyber_hound, sol_ring, squirrel_nest,
    toph_the_first_metalbender, urzas_saga,
};
use crate::combat_state::{AttackTarget, CombatError, new_combat};
use crate::continuous::{ContinuousEffect, EffectTarget, Modification, PtSublayer};
use crate::decision::AttackerDeclaration;
use crate::effect::{Until, Value};
use crate::game_loop::{GameLoopError, apply_attacker_declarations};
use crate::game_state::{GameState, Phase};
use crate::ids::{CardId, PlayerId};
use crate::object::CounterType;
use crate::static_abilities::StaticAbility;
use crate::triggers::TriggerQueue;
use crate::types::{CardType, Subtype};
use crate::zone::Zone;

/// Helper to create a basic game state for testing.
fn setup_game() -> GameState {
    GameState::new(vec!["Alice".to_string(), "Bob".to_string()], 20)
}

// =============================================================================
// Blood Moon Interaction Tests
// =============================================================================
//
// These tests verify Blood Moon's interaction with other permanents.
// Blood Moon is an enchantment with a static ability that:
// - Layer 4: Changes nonbasic land subtypes to Mountain
// - Layer 6: Removes all abilities from nonbasic lands
// The static ability is defined in ability.rs as StaticAbility::BloodMoon,
// and the continuous effects are generated by static_ability_processor.rs.

/// Tests Blood Moon's effect on Urza's Saga's types and subtypes.
///
/// Scenario: Urza's Saga (Enchantment Land - Urza's Saga) is on the battlefield with
/// 2 lore counters. Blood Moon enters the battlefield.
///
/// Expected behavior:
/// - Urza's Saga remains an Enchantment Land (card types unchanged)
/// - Urza's Saga loses land subtypes (Urza's) and gains Mountain
/// - Urza's Saga keeps enchantment subtypes (Saga)
///
/// This tests Layer 4 type-changing effects.
#[test]
fn test_urzas_saga_under_blood_moon_type_changes() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create Urza's Saga on battlefield
    let saga_def = urzas_saga();
    let saga_id = game.create_object_from_definition(&saga_def, alice, Zone::Battlefield);

    // Add 2 lore counters
    game.object_mut(saga_id)
        .unwrap()
        .add_counters(CounterType::Lore, 2);

    // Create Blood Moon on battlefield using the proper card definition.
    // The static ability processor will generate the continuous effects
    // from Blood Moon's StaticAbility::BloodMoon.
    let blood_moon_def = blood_moon();
    let _blood_moon_id =
        game.create_object_from_definition(&blood_moon_def, alice, Zone::Battlefield);

    // Urza's Saga should still be an Enchantment (Blood Moon only affects land aspects)
    assert!(
        game.object_has_card_type(saga_id, CardType::Enchantment),
        "Urza's Saga should still be an Enchantment under Blood Moon"
    );

    // Urza's Saga should still be a Land
    assert!(
        game.object_has_card_type(saga_id, CardType::Land),
        "Urza's Saga should still be a Land under Blood Moon"
    );

    // The Saga enchantment subtype should remain (it's not a land subtype)
    // Blood Moon's SetSubtypes only replaces land subtypes, keeping non-land subtypes
    let subtypes = game.calculated_subtypes(saga_id);
    assert!(
        subtypes.contains(&Subtype::Mountain),
        "Urza's Saga should have Mountain subtype from Blood Moon"
    );

    // Blood Moon properly only affects land subtypes
    assert!(
        subtypes.contains(&Subtype::Saga),
        "Should keep Saga subtype (it's an enchantment subtype, not a land subtype)"
    );
    assert!(
        !subtypes.contains(&Subtype::Urzas),
        "Should lose Urza's subtype (it's a land subtype)"
    );
}

/// Tests Blood Moon's effect on Urza's Saga's abilities.
///
/// Scenario: Urza's Saga is on the battlefield. Blood Moon enters.
///
/// Expected behavior:
/// - Urza's Saga loses all abilities (including chapter abilities)
/// - Mountains have intrinsic mana abilities per MTG rule 305.6
///
/// This tests Layer 6 ability-removing effects.
#[test]
fn test_urzas_saga_under_blood_moon_loses_chapter_abilities() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create Urza's Saga
    let saga_def = urzas_saga();
    let saga_id = game.create_object_from_definition(&saga_def, alice, Zone::Battlefield);

    // Create Blood Moon using the proper card definition
    let blood_moon_def = blood_moon();
    let _blood_moon_id =
        game.create_object_from_definition(&blood_moon_def, alice, Zone::Battlefield);

    // Under Blood Moon, Urza's Saga should have no chapter abilities
    // (They are removed as part of "remove all abilities")
    let chars = game.calculated_characteristics(saga_id).unwrap();
    let has_chapter_ability = chars.abilities.iter().any(|a| {
        if let AbilityKind::Triggered(t) = &a.kind {
            t.trigger.display().starts_with("Saga chapter")
        } else {
            false
        }
    });

    assert!(
        !has_chapter_ability,
        "Urza's Saga under Blood Moon should have no chapter abilities"
    );

    // Note: Mountains have intrinsic mana abilities per MTG rule 305.6.
    // The mana ability "{T}: Add {R}" is a consequence of being a Mountain,
    // not an explicitly granted ability. The key test here is that chapter
    // abilities are removed; the mana ability handling is a separate concern.
}

// =============================================================================
// Dependency Interaction Tests (Toph / Mycosynth Lattice / Blood Moon)
// =============================================================================

#[test]
fn test_toph_mycosynth_blood_moon_dependency_chain() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    let ring_def = sol_ring();
    let ring_id = game.create_object_from_definition(&ring_def, alice, Zone::Battlefield);

    let lattice_def = mycosynth_lattice();
    let _lattice_id = game.create_object_from_definition(&lattice_def, alice, Zone::Battlefield);

    let toph_def = toph_the_first_metalbender();
    let _toph_id = game.create_object_from_definition(&toph_def, alice, Zone::Battlefield);

    let blood_moon_def = blood_moon();
    let _blood_moon_id =
        game.create_object_from_definition(&blood_moon_def, alice, Zone::Battlefield);

    let chars = game
        .calculated_characteristics(ring_id)
        .expect("should calculate characteristics");

    assert!(
        chars.card_types.contains(&CardType::Artifact),
        "Sol Ring should remain an artifact"
    );
    assert!(
        chars.card_types.contains(&CardType::Land),
        "Sol Ring should become a land via Toph after Mycosynth Lattice"
    );
    assert!(
        chars.subtypes.contains(&Subtype::Mountain),
        "Sol Ring should become a Mountain due to Blood Moon"
    );
    assert!(
        chars.abilities.is_empty(),
        "Sol Ring should lose abilities due to Blood Moon"
    );
}

// =============================================================================
// Dependency Interaction Tests (Marvin / Rex / Humility)
// =============================================================================

#[test]
fn test_marvin_loses_copied_abilities_under_humility() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    let marvin_def = marvin_murderous_mimic();
    let marvin_id = game.create_object_from_definition(&marvin_def, alice, Zone::Battlefield);

    let elf_def = crate::cards::definitions::llanowar_elves();
    let _elf_id = game.create_object_from_definition(&elf_def, alice, Zone::Battlefield);

    let humility_def = humility();
    let _humility_id = game.create_object_from_definition(&humility_def, alice, Zone::Battlefield);

    let chars = game
        .calculated_characteristics(marvin_id)
        .expect("should calculate characteristics");

    let has_activated = chars
        .abilities
        .iter()
        .any(|a| matches!(a.kind, AbilityKind::Activated(_) | AbilityKind::Mana(_)));
    assert!(
        !has_activated,
        "Marvin should not copy abilities when Humility removes them"
    );
}

#[test]
fn test_marvin_copies_rex_brain_counter_abilities() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    let rex_def = rex_cyber_hound();
    let _rex_id = game.create_object_from_definition(&rex_def, alice, Zone::Battlefield);

    let marvin_def = marvin_murderous_mimic();
    let marvin_id = game.create_object_from_definition(&marvin_def, alice, Zone::Battlefield);

    let exiled_def = high_market();
    let exiled_id = game.create_object_from_definition(&exiled_def, alice, Zone::Exile);
    game.object_mut(exiled_id)
        .unwrap()
        .add_counters(CounterType::Brain, 1);

    let chars = game
        .calculated_characteristics(marvin_id)
        .expect("should calculate characteristics");

    let has_activated = chars
        .abilities
        .iter()
        .any(|a| matches!(a.kind, AbilityKind::Activated(_) | AbilityKind::Mana(_)));
    assert!(
        has_activated,
        "Marvin should copy activated abilities from Rex via brain-counter cards"
    );
}

#[test]
fn test_manascape_refractor_copies_squirrel_nest_ability() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    let forest_def = crate::cards::definitions::basic_forest();
    let forest_id = game.create_object_from_definition(&forest_def, alice, Zone::Battlefield);

    let nest_def = squirrel_nest();
    let nest_id = game.create_object_from_definition(&nest_def, alice, Zone::Battlefield);

    {
        let nest = game.object_mut(nest_id).unwrap();
        nest.attached_to = Some(forest_id);
    }
    {
        let forest = game.object_mut(forest_id).unwrap();
        forest.attachments.push(nest_id);
    }

    let refractor_def = manascape_refractor();
    let refractor_id = game.create_object_from_definition(&refractor_def, alice, Zone::Battlefield);

    let chars = game
        .calculated_characteristics(refractor_id)
        .expect("should calculate characteristics");

    let has_squirrel_ability = chars.abilities.iter().any(|a| {
        a.text
            .as_deref()
            .is_some_and(|t| t.to_ascii_lowercase().contains("squirrel creature token"))
    });

    assert!(
        has_squirrel_ability,
        "Manascape Refractor should copy the activated ability granted by Squirrel Nest"
    );
}

/// Tests that Urza's Saga survives under Blood Moon even with max lore counters.
///
/// Scenario: Urza's Saga has 3 lore counters (would normally sacrifice).
/// Blood Moon enters the battlefield.
///
/// Expected behavior:
/// - Urza's Saga loses all chapter abilities
/// - A Saga with no chapter abilities is NOT sacrificed by state-based actions
/// - Urza's Saga remains on the battlefield
///
/// This tests the interaction between Layer 6 and Saga sacrifice SBAs.
#[test]
fn test_urzas_saga_under_blood_moon_survives_without_chapter_abilities() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create Urza's Saga with 3 lore counters (normally would trigger sacrifice)
    let saga_def = urzas_saga();
    let saga_id = game.create_object_from_definition(&saga_def, alice, Zone::Battlefield);
    game.object_mut(saga_id)
        .unwrap()
        .add_counters(CounterType::Lore, 3);

    // Create Blood Moon using the proper card definition (removes chapter abilities)
    let blood_moon_def = blood_moon();
    let _blood_moon_id =
        game.create_object_from_definition(&blood_moon_def, alice, Zone::Battlefield);

    // Per new rules: A Saga with no chapter abilities won't be sacrificed
    // even if it has lore counters >= its chapter count
    let sbas = crate::rules::check_state_based_actions(&game);

    // Should NOT have a saga sacrifice SBA
    let has_saga_sacrifice = sbas.iter().any(|sba| {
        matches!(
            sba,
            crate::rules::state_based::StateBasedAction::SagaSacrifice { .. }
        )
    });

    assert!(
        !has_saga_sacrifice,
        "Urza's Saga with no chapter abilities (under Blood Moon) should NOT be sacrificed"
    );

    // Verify the saga is still on the battlefield
    assert!(
        game.battlefield.contains(&saga_id),
        "Urza's Saga should remain on battlefield under Blood Moon"
    );
}

/// Tests Urza's Saga gaining lore counters under Blood Moon without triggering.
///
/// Scenario: Urza's Saga has 1 lore counter, Blood Moon is on the battlefield.
/// The precombat main phase begins.
///
/// Expected behavior:
/// - Urza's Saga gains a lore counter (it's still a Saga subtype)
/// - No chapter abilities trigger (they were removed by Blood Moon)
///
/// This tests the interaction between Layer 6, Saga mechanics, and triggers.
#[test]
fn test_urzas_saga_under_blood_moon_gains_lore_counter_but_no_triggers() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);
    game.turn.active_player = alice;
    game.turn.phase = Phase::FirstMain;

    // Create Urza's Saga with 1 lore counter
    let saga_def = urzas_saga();
    let saga_id = game.create_object_from_definition(&saga_def, alice, Zone::Battlefield);
    game.object_mut(saga_id)
        .unwrap()
        .add_counters(CounterType::Lore, 1);

    // Create Blood Moon using the proper card definition
    let blood_moon_def = blood_moon();
    let _blood_moon_id =
        game.create_object_from_definition(&blood_moon_def, alice, Zone::Battlefield);

    let initial_lore = game
        .object(saga_id)
        .unwrap()
        .counters
        .get(&CounterType::Lore)
        .copied()
        .unwrap_or(0);

    // Process the precombat main phase lore counter addition
    // Urza's Saga keeps its Saga subtype under Blood Moon (since Saga is an enchantment
    // subtype, not a land subtype), so it still gains lore counters each turn.
    // However, no chapter abilities will trigger because Blood Moon removes all abilities.
    let mut trigger_queue = crate::triggers::TriggerQueue::new();
    crate::game_loop::add_saga_lore_counters(&mut game, &mut trigger_queue);

    let final_lore = game
        .object(saga_id)
        .unwrap()
        .counters
        .get(&CounterType::Lore)
        .copied()
        .unwrap_or(0);

    // Urza's Saga still has Saga subtype, so it gains a lore counter
    assert_eq!(
        initial_lore + 1,
        final_lore,
        "Urza's Saga under Blood Moon should still gain lore counters (it's still a Saga)"
    );

    // But no chapter abilities should have triggered (they were removed by Blood Moon)
    assert!(
        trigger_queue.is_empty(),
        "No chapter abilities should trigger (Blood Moon removed all abilities)"
    );
}

// =============================================================================
// Humility + Crusade Tests (Layer 6 + Layer 7 interaction)
// =============================================================================
//
// These tests verify Humility and Crusade interactions.
// Humility is an enchantment with a static ability that:
// - Layer 6: Removes all abilities from creatures
// - Layer 7b: Sets all creatures' base P/T to 1/1
// Crusade is an enchantment that grants +1/+1 to white creatures (Layer 7c).

/// Tests that Humility sets all creatures to 1/1.
///
/// Scenario: A 4/4 creature is on the battlefield. Humility enters.
///
/// Expected behavior:
/// - Layer 7b: Creature's P/T is set to 1/1
/// - The creature becomes 1/1 regardless of its printed P/T
#[test]
fn test_humility_sets_creatures_to_1_1() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create a 4/4 creature
    let creature = CardBuilder::new(CardId::from_raw(100), "Big Creature")
        .card_types(vec![CardType::Creature])
        .power_toughness(PowerToughness::fixed(4, 4))
        .build();
    let creature_id = game.create_object_from_card(&creature, alice, Zone::Battlefield);

    // Create Humility using the proper card definition
    let humility_def = humility();
    let _humility_id = game.create_object_from_definition(&humility_def, alice, Zone::Battlefield);

    assert_eq!(
        game.calculated_power(creature_id),
        Some(1),
        "Creature under Humility should have power 1"
    );
    assert_eq!(
        game.calculated_toughness(creature_id),
        Some(1),
        "Creature under Humility should have toughness 1"
    );
}

/// Tests Humility + Crusade interaction results in 2/2.
///
/// Scenario: A white 4/4 creature with flying is on the battlefield.
/// Humility enters (earlier timestamp), then Crusade enters.
///
/// Expected behavior:
/// - Layer 6: Humility removes all abilities (creature loses flying)
/// - Layer 7b: Humility sets P/T to 1/1
/// - Layer 7c: Crusade gives +1/+1 to white creatures
/// - Final result: 2/2 creature with no abilities
#[test]
fn test_humility_plus_crusade_results_in_2_2() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create a white 4/4 creature with flying
    let creature = CardBuilder::new(CardId::from_raw(100), "Serra Angel")
        .card_types(vec![CardType::Creature])
        .color_indicator(crate::color::ColorSet::WHITE)
        .power_toughness(PowerToughness::fixed(4, 4))
        .build();
    let creature_id = game.create_object_from_card(&creature, alice, Zone::Battlefield);

    // Add flying ability
    game.object_mut(creature_id)
        .unwrap()
        .abilities
        .push(Ability::static_ability(StaticAbility::flying()));

    // Create Humility using the proper card definition (earlier timestamp)
    let humility_def = humility();
    let _humility_id = game.create_object_from_definition(&humility_def, alice, Zone::Battlefield);

    // Create Crusade using the proper card definition (later timestamp)
    let crusade_def = crusade();
    let _crusade_id = game.create_object_from_definition(&crusade_def, alice, Zone::Battlefield);

    // Layer 7b (Humility): Sets to 1/1
    // Layer 7c (Crusade): +1/+1
    // Result should be 2/2
    assert_eq!(
        game.calculated_power(creature_id),
        Some(2),
        "Creature under Humility + Crusade should be 2/2 (1/1 base + 1/1 from Crusade)"
    );
    assert_eq!(
        game.calculated_toughness(creature_id),
        Some(2),
        "Creature under Humility + Crusade should be 2/2"
    );

    // Should have no abilities (Humility removes them in Layer 6)
    assert!(
        !game.object_has_ability(creature_id, &StaticAbility::flying()),
        "Creature under Humility should lose flying"
    );
}

// =============================================================================
// Turn to Frog + Giant Growth Tests (Layer 7 sublayer ordering)
// =============================================================================
//
// These tests verify that Layer 7 sublayers are applied in the correct order:
// - 7a: Characteristic-defining abilities
// - 7b: Effects that SET power/toughness (e.g., Turn to Frog's "becomes 1/1")
// - 7c: Effects that MODIFY power/toughness (e.g., Giant Growth's "+3/+3")
// - 7d: Counter modifications (+1/+1, -1/-1 counters)
// - 7e: Effects that switch power and toughness
//
// Per MTG Rule 613.4, effects within the same sublayer are applied in timestamp
// order, but effects in different sublayers always apply in sublayer order.
// This means Turn to Frog (7b) always applies before Giant Growth (7c).

/// Tests Turn to Frog (7b) followed by Giant Growth (7c).
///
/// Scenario: A 4/4 creature is on the battlefield. Turn to Frog sets it to 1/1
/// (Layer 7b), then Giant Growth gives it +3/+3 (Layer 7c).
///
/// Expected behavior:
/// - Layer 7b: Turn to Frog sets base P/T to 1/1
/// - Layer 7c: Giant Growth modifies P/T by +3/+3
/// - Result: 4/4 (1+3, 1+3)
///
/// This tests that sublayer ordering is applied correctly (7b before 7c).
#[test]
fn test_turn_to_frog_then_giant_growth() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create a 4/4 creature
    let creature = CardBuilder::new(CardId::from_raw(100), "Big Creature")
        .card_types(vec![CardType::Creature])
        .power_toughness(PowerToughness::fixed(4, 4))
        .build();
    let creature_id = game.create_object_from_card(&creature, alice, Zone::Battlefield);

    let source = game.new_object_id();

    // Turn to Frog: Target becomes a 1/1 blue Frog (Layer 7b: setting)
    let turn_to_frog = ContinuousEffect::new(
        source,
        alice,
        EffectTarget::Specific(creature_id),
        Modification::SetPowerToughness {
            power: Value::Fixed(1),
            toughness: Value::Fixed(1),
            sublayer: PtSublayer::Setting,
        },
    )
    .until(Until::EndOfTurn);
    game.continuous_effects.add_effect(turn_to_frog);

    // Giant Growth: +3/+3 (Layer 7c: modifying)
    let giant_growth = ContinuousEffect::new(
        source,
        alice,
        EffectTarget::Specific(creature_id),
        Modification::ModifyPowerToughness {
            power: 3,
            toughness: 3,
        },
    )
    .until(Until::EndOfTurn);
    game.continuous_effects.add_effect(giant_growth);

    // Layer 7b applies first: base becomes 1/1
    // Layer 7c applies second: +3/+3
    // Result: 4/4
    assert_eq!(
        game.calculated_power(creature_id),
        Some(4),
        "Turn to Frog (1/1) + Giant Growth (+3/+3) should result in 4/4 power"
    );
    assert_eq!(
        game.calculated_toughness(creature_id),
        Some(4),
        "Turn to Frog (1/1) + Giant Growth (+3/+3) should result in 4/4 toughness"
    );
}

/// Tests Giant Growth (7c) followed by Turn to Frog (7b) - reverse timestamp order.
///
/// Scenario: A 2/2 creature is on the battlefield. Giant Growth gives it +3/+3
/// (earlier timestamp), then Turn to Frog sets it to 1/1 (later timestamp).
///
/// Expected behavior:
/// - Layer 7b: Turn to Frog sets base P/T to 1/1 (despite later timestamp)
/// - Layer 7c: Giant Growth modifies P/T by +3/+3
/// - Result: 4/4 (1+3, 1+3)
///
/// This tests that sublayer ordering beats timestamp ordering. Even though
/// Giant Growth was "cast" first (earlier timestamp), Turn to Frog's 7b
/// effect applies before Giant Growth's 7c effect.
#[test]
fn test_giant_growth_then_turn_to_frog() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create a 2/2 creature
    let creature = CardBuilder::new(CardId::from_raw(100), "Bear")
        .card_types(vec![CardType::Creature])
        .power_toughness(PowerToughness::fixed(2, 2))
        .build();
    let creature_id = game.create_object_from_card(&creature, alice, Zone::Battlefield);

    let source = game.new_object_id();

    // Giant Growth first (earlier timestamp): +3/+3 (Layer 7c)
    let giant_growth = ContinuousEffect::new(
        source,
        alice,
        EffectTarget::Specific(creature_id),
        Modification::ModifyPowerToughness {
            power: 3,
            toughness: 3,
        },
    )
    .until(Until::EndOfTurn);
    game.continuous_effects.add_effect(giant_growth);

    // Turn to Frog second (later timestamp): 1/1 (Layer 7b)
    let turn_to_frog = ContinuousEffect::new(
        source,
        alice,
        EffectTarget::Specific(creature_id),
        Modification::SetPowerToughness {
            power: Value::Fixed(1),
            toughness: Value::Fixed(1),
            sublayer: PtSublayer::Setting,
        },
    )
    .until(Until::EndOfTurn);
    game.continuous_effects.add_effect(turn_to_frog);

    // Even though Giant Growth was cast first, layers apply in order:
    // Layer 7b (Turn to Frog): sets to 1/1
    // Layer 7c (Giant Growth): +3/+3
    // Result: 4/4 (same as above - timestamp doesn't matter across sublayers)
    assert_eq!(
        game.calculated_power(creature_id),
        Some(4),
        "Layer order (not timestamp) determines result: should be 4/4"
    );
    assert_eq!(
        game.calculated_toughness(creature_id),
        Some(4),
        "Layer order (not timestamp) determines result: should be 4/4"
    );
}

// =============================================================================
// Copy Effect Tests (Layer 1)
// =============================================================================

/// Test: Clone copies base characteristics, not modifications.
///
/// Scenario: A 2/2 Grizzly Bears has a +3/+3 pump effect making it 5/5. A Clone
/// enters copying the Bears. Copy effects apply in Layer 1, which copies only
/// the BASE characteristics (name, types, abilities, printed P/T). The pump
/// effect (+3/+3) is NOT copied because it's a Layer 7c modification, not a
/// base characteristic. Clone becomes a 2/2 Bear, not a 5/5.
///
/// Note: This test uses direct ContinuousEffect creation because it's testing
/// Layer 1 copy effect behavior. Copy effects are not yet fully implemented.
#[test]
fn test_clone_copies_base_not_modifications() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create a 2/2 Bear
    let bear = CardBuilder::new(CardId::from_raw(100), "Grizzly Bears")
        .card_types(vec![CardType::Creature])
        .subtypes(vec![Subtype::Bear])
        .power_toughness(PowerToughness::fixed(2, 2))
        .build();
    let bear_id = game.create_object_from_card(&bear, alice, Zone::Battlefield);

    // Give the bear +3/+3 (temporary pump)
    let source = game.new_object_id();
    let pump = ContinuousEffect::new(
        source,
        alice,
        EffectTarget::Specific(bear_id),
        Modification::ModifyPowerToughness {
            power: 3,
            toughness: 3,
        },
    )
    .until(Until::EndOfTurn);
    game.continuous_effects.add_effect(pump);

    // The pumped bear should be 5/5
    assert_eq!(
        game.calculated_power(bear_id),
        Some(5),
        "Pumped bear should be 5/5"
    );

    // Create a Clone that copies the bear
    let clone_card = CardBuilder::new(CardId::from_raw(101), "Clone")
        .card_types(vec![CardType::Creature])
        .subtypes(vec![Subtype::Shapeshifter])
        .power_toughness(PowerToughness::fixed(0, 0))
        .build();
    let clone_id = game.create_object_from_card(&clone_card, alice, Zone::Battlefield);

    // Apply copy effect in Layer 1
    let copy_effect = ContinuousEffect::new(
        clone_id,
        alice,
        EffectTarget::Source,
        Modification::CopyOf(bear_id),
    );
    game.continuous_effects.add_effect(copy_effect);

    // Clone should copy the BASE characteristics, not the pumped stats
    // Clone becomes a 2/2 Bear, not a 5/5
    // NOTE: Copy effects (Layer 1) are not yet implemented in calculate_characteristics
    // For now, this test documents expected behavior
    assert_eq!(
        game.calculated_power(clone_id),
        Some(2),
        "Clone should copy base power (2), not pumped power (5)"
    );
    assert_eq!(
        game.calculated_toughness(clone_id),
        Some(2),
        "Clone should copy base toughness (2), not pumped toughness (5)"
    );

    // Clone should have Bear creature type
    let subtypes = game.calculated_subtypes(clone_id);
    assert!(
        subtypes.contains(&Subtype::Bear),
        "Clone should copy Bear subtype"
    );
}

// =============================================================================
// P/T Switching Tests (Layer 7e)
// =============================================================================

/// Test: P/T switching happens AFTER pump effects in Layer 7e.
///
/// Scenario: A 1/4 Wall has a +2/+0 pump effect, then a P/T switch effect. The
/// layer system applies these in order: Layer 7c pump makes it 3/4, then Layer 7e
/// switch swaps power and toughness, resulting in 4/3. This demonstrates that
/// switching happens after all other P/T modifications.
///
/// Note: This test uses direct ContinuousEffect creation because it's testing
/// the ordering of Layer 7c (modification) and Layer 7e (switching) effects.
#[test]
fn test_switch_power_toughness_after_pump() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create a 1/4 creature
    let creature = CardBuilder::new(CardId::from_raw(100), "Wall")
        .card_types(vec![CardType::Creature])
        .power_toughness(PowerToughness::fixed(1, 4))
        .build();
    let creature_id = game.create_object_from_card(&creature, alice, Zone::Battlefield);

    let source = game.new_object_id();

    // Give it +2/+0 (Layer 7c)
    let pump = ContinuousEffect::new(
        source,
        alice,
        EffectTarget::Specific(creature_id),
        Modification::ModifyPowerToughness {
            power: 2,
            toughness: 0,
        },
    )
    .until(Until::EndOfTurn);
    game.continuous_effects.add_effect(pump);

    // Switch P/T (Layer 7e)
    let switch = ContinuousEffect::new(
        source,
        alice,
        EffectTarget::Specific(creature_id),
        Modification::SwitchPowerToughness,
    )
    .until(Until::EndOfTurn);
    game.continuous_effects.add_effect(switch);

    // Base: 1/4
    // After pump (7c): 3/4
    // After switch (7e): 4/3
    assert_eq!(
        game.calculated_power(creature_id),
        Some(4),
        "After pump and switch: power should be 4 (was toughness)"
    );
    assert_eq!(
        game.calculated_toughness(creature_id),
        Some(3),
        "After pump and switch: toughness should be 3 (was power)"
    );
}

// =============================================================================
// +1/+1 and -1/-1 Counter Interaction Tests (Layer 7d)
// =============================================================================

/// Test: Counters apply in Layer 7d after P/T setting effects in Layer 7b.
///
/// Scenario: A 2/2 Bear has two +1/+1 counters on it. Turn to Frog effect
/// sets its P/T to 1/1 in Layer 7b. The layer system processes effects in
/// order: Layer 7b sets to 1/1, then Layer 7d adds +2/+2 from counters.
/// Final result is 3/3.
///
/// Note: This test uses direct ContinuousEffect creation because it's testing
/// the layer system's ordering logic, not the full game simulation.
#[test]
fn test_counters_apply_in_layer_7d() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create a 2/2 creature
    let creature = CardBuilder::new(CardId::from_raw(100), "Bear")
        .card_types(vec![CardType::Creature])
        .power_toughness(PowerToughness::fixed(2, 2))
        .build();
    let creature_id = game.create_object_from_card(&creature, alice, Zone::Battlefield);

    // Add +1/+1 counters
    game.object_mut(creature_id)
        .unwrap()
        .add_counters(CounterType::PlusOnePlusOne, 2);

    let source = game.new_object_id();

    // Turn to Frog: Set to 1/1 (Layer 7b)
    let turn_to_frog = ContinuousEffect::new(
        source,
        alice,
        EffectTarget::Specific(creature_id),
        Modification::SetPowerToughness {
            power: Value::Fixed(1),
            toughness: Value::Fixed(1),
            sublayer: PtSublayer::Setting,
        },
    )
    .until(Until::EndOfTurn);
    game.continuous_effects.add_effect(turn_to_frog);

    // Layer 7b: Set to 1/1
    // Layer 7d: +1/+1 counters add +2/+2
    // Result: 3/3
    assert_eq!(
        game.calculated_power(creature_id),
        Some(3),
        "Turn to Frog (1/1) + 2 +1/+1 counters should result in 3/3"
    );
    assert_eq!(
        game.calculated_toughness(creature_id),
        Some(3),
        "Turn to Frog (1/1) + 2 +1/+1 counters should result in 3/3"
    );
}

// =============================================================================
// Timestamp Ordering Tests (within same layer)
// =============================================================================

/// Test: Within the same sublayer, later timestamp wins.
///
/// Scenario: A 2/2 Bear has two "set P/T" effects applied in Layer 7b. The first
/// effect (earlier timestamp) sets it to 5/5. The second effect (later timestamp)
/// sets it to 1/1. Within the same sublayer, effects are applied in timestamp order,
/// with later timestamps overwriting earlier ones. Final result is 1/1.
///
/// Note: This test uses direct ContinuousEffect creation because it's testing
/// timestamp ordering within a layer, not the full game simulation.
#[test]
fn test_timestamp_ordering_for_setting_effects() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create a 2/2 creature
    let creature = CardBuilder::new(CardId::from_raw(100), "Bear")
        .card_types(vec![CardType::Creature])
        .power_toughness(PowerToughness::fixed(2, 2))
        .build();
    let creature_id = game.create_object_from_card(&creature, alice, Zone::Battlefield);

    let source = game.new_object_id();

    // First effect: Set to 5/5 (earlier timestamp)
    let effect1 = ContinuousEffect::new(
        source,
        alice,
        EffectTarget::Specific(creature_id),
        Modification::SetPowerToughness {
            power: Value::Fixed(5),
            toughness: Value::Fixed(5),
            sublayer: PtSublayer::Setting,
        },
    )
    .until(Until::EndOfTurn);
    game.continuous_effects.add_effect(effect1);

    // Second effect: Set to 1/1 (later timestamp)
    let effect2 = ContinuousEffect::new(
        source,
        alice,
        EffectTarget::Specific(creature_id),
        Modification::SetPowerToughness {
            power: Value::Fixed(1),
            toughness: Value::Fixed(1),
            sublayer: PtSublayer::Setting,
        },
    )
    .until(Until::EndOfTurn);
    game.continuous_effects.add_effect(effect2);

    // Within the same sublayer, later timestamp wins
    // So creature should be 1/1
    assert_eq!(
        game.calculated_power(creature_id),
        Some(1),
        "Later timestamp setting effect should override earlier one"
    );
    assert_eq!(
        game.calculated_toughness(creature_id),
        Some(1),
        "Later timestamp setting effect should override earlier one"
    );
}

// =============================================================================
// Level-Up + Humility Tests (Dependency Detection)
// =============================================================================
//
// Per MTG Rules:
// - Level symbols are static abilities (711.2) that generate continuous effects
// - "As long as this creature has N+ level counters, it has base P/T [X/Y] and has [abilities]"
// - The P/T setting is Layer 7b, ability granting is Layer 6
// - Humility's "lose all abilities" removes the level symbol ability itself
// - This creates a DEPENDENCY: level effects depend on Humility's effect
// - Per CR 613.8, the depended-on effect applies first regardless of timestamp
// - Result: Leveler under Humility is ALWAYS 1/1 with no abilities

use crate::cards::definitions::student_of_warfare;

/// Test: Student of Warfare has base 1/1 stats with no abilities at level 0.
///
/// Scenario: Alice casts Student of Warfare from her hand. Without any level counters,
/// it should be a 1/1 creature with no first strike or double strike abilities.
#[test]
fn test_student_of_warfare_base_stats() {
    use crate::cards::definitions::basic_plains;
    use crate::game_state::StackEntry;
    use crate::mana::ManaSymbol;

    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Set up game in main phase with priority
    game.turn.phase = Phase::FirstMain;
    game.turn.step = None;
    game.turn.active_player = alice;
    game.turn.priority_player = Some(alice);

    // Create Plains for mana and Student of Warfare in hand
    let plains = basic_plains();
    let plains_id = game.create_object_from_definition(&plains, alice, Zone::Battlefield);
    game.remove_summoning_sickness(plains_id);

    let def = student_of_warfare();
    let student_in_hand = game.create_object_from_definition(&def, alice, Zone::Hand);

    // Tap Plains for white mana
    game.tap(plains_id);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .add(ManaSymbol::White, 1);

    // Cast Student of Warfare
    let stack_student_id = game.move_object(student_in_hand, Zone::Stack).unwrap();
    let entry = StackEntry::new(stack_student_id, alice);
    game.push_to_stack(entry);

    // Pay the mana cost
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .remove(ManaSymbol::White, 1);

    // Resolve - Student enters battlefield
    resolve_stack_entry(&mut game).expect("Student should resolve");

    // Find the Student on battlefield (new ID after zone change)
    let student_id = game
        .battlefield
        .iter()
        .filter_map(|&id| game.object(id))
        .find(|obj| obj.name == "Student of Warfare" && obj.controller == alice)
        .map(|obj| obj.id)
        .expect("Student should be on battlefield");

    // Verify no level counters
    assert_eq!(
        game.object(student_id)
            .unwrap()
            .counters
            .get(&CounterType::Level),
        None,
        "Student should have no level counters"
    );

    // At 0 level counters, should be base 1/1 with no special abilities
    assert_eq!(
        game.calculated_power(student_id),
        Some(1),
        "Student at level 0 should be 1/1"
    );
    assert_eq!(
        game.calculated_toughness(student_id),
        Some(1),
        "Student at level 0 should be 1/1"
    );
    assert!(
        !game.object_has_ability(student_id, &StaticAbility::first_strike()),
        "Student at level 0 should not have first strike"
    );
    assert!(
        !game.object_has_ability(student_id, &StaticAbility::double_strike()),
        "Student at level 0 should not have double strike"
    );
}

/// Test: Student of Warfare at level 2 is 3/3 with first strike.
///
/// Scenario: Alice casts Student of Warfare and activates its level-up ability twice
/// during her main phase. At level 2, the Student becomes a 3/3 with first strike.
#[test]
fn test_student_of_warfare_level_2() {
    use crate::cards::definitions::basic_plains;
    use crate::game_state::StackEntry;
    use crate::mana::ManaSymbol;

    let mut game = setup_game();
    let alice = PlayerId::from_index(0);
    let mut trigger_queue = TriggerQueue::default();
    let mut state = PriorityLoopState::new(2);

    // Set up game in main phase with priority
    game.turn.phase = Phase::FirstMain;
    game.turn.step = None;
    game.turn.active_player = alice;
    game.turn.priority_player = Some(alice);

    // Create 3 Plains for mana (1 for casting, 2 for level-ups)
    let plains = basic_plains();
    let plains1_id = game.create_object_from_definition(&plains, alice, Zone::Battlefield);
    let plains2_id = game.create_object_from_definition(&plains, alice, Zone::Battlefield);
    let plains3_id = game.create_object_from_definition(&plains, alice, Zone::Battlefield);
    game.remove_summoning_sickness(plains1_id);
    game.remove_summoning_sickness(plains2_id);
    game.remove_summoning_sickness(plains3_id);

    let def = student_of_warfare();
    let student_in_hand = game.create_object_from_definition(&def, alice, Zone::Hand);

    // Cast Student of Warfare (costs {W})
    game.tap(plains1_id);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .add(ManaSymbol::White, 1);

    let stack_student_id = game.move_object(student_in_hand, Zone::Stack).unwrap();
    let entry = StackEntry::new(stack_student_id, alice);
    game.push_to_stack(entry);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .remove(ManaSymbol::White, 1);

    resolve_stack_entry(&mut game).expect("Student should resolve");

    // Find the Student on battlefield
    let student_id = game
        .battlefield
        .iter()
        .filter_map(|&id| game.object(id))
        .find(|obj| obj.name == "Student of Warfare" && obj.controller == alice)
        .map(|obj| obj.id)
        .expect("Student should be on battlefield");

    // Level-up #1: Activate level-up ability (costs {W})
    // Level-up is a sorcery-speed ability (index 0)
    game.tap(plains2_id);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .add(ManaSymbol::White, 1);

    let activate_action = LegalAction::ActivateAbility {
        source: student_id,
        ability_index: 0,
    };
    let response = PriorityResponse::PriorityAction(activate_action);
    let _progress = apply_priority_response(&mut game, &mut trigger_queue, &mut state, &response)
        .expect("Level-up activation should succeed");

    // The mana should auto-pay since we have {W} in pool, ability goes on stack
    assert!(
        !game.stack_is_empty(),
        "Level-up ability should be on stack"
    );

    // Resolve level-up ability
    resolve_stack_entry(&mut game).expect("Level-up should resolve");

    // Verify 1 level counter
    assert_eq!(
        game.object(student_id)
            .unwrap()
            .counters
            .get(&CounterType::Level),
        Some(&1),
        "Student should have 1 level counter after first level-up"
    );

    // Level-up #2: Activate level-up ability again
    game.tap(plains3_id);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .add(ManaSymbol::White, 1);

    let activate_action = LegalAction::ActivateAbility {
        source: student_id,
        ability_index: 0,
    };
    let response = PriorityResponse::PriorityAction(activate_action);
    let _progress = apply_priority_response(&mut game, &mut trigger_queue, &mut state, &response)
        .expect("Level-up activation should succeed");

    assert!(
        !game.stack_is_empty(),
        "Level-up ability should be on stack"
    );

    resolve_stack_entry(&mut game).expect("Level-up should resolve");

    // Verify 2 level counters
    assert_eq!(
        game.object(student_id)
            .unwrap()
            .counters
            .get(&CounterType::Level),
        Some(&2),
        "Student should have 2 level counters"
    );

    // At level 2-6: 3/3 with first strike
    assert_eq!(
        game.calculated_power(student_id),
        Some(3),
        "Student at level 2 should be 3/3"
    );
    assert_eq!(
        game.calculated_toughness(student_id),
        Some(3),
        "Student at level 2 should be 3/3"
    );
    assert!(
        game.object_has_ability(student_id, &StaticAbility::first_strike()),
        "Student at level 2 should have first strike"
    );
    assert!(
        !game.object_has_ability(student_id, &StaticAbility::double_strike()),
        "Student at level 2 should not have double strike yet"
    );
}

/// Test: Student of Warfare at level 7 is 4/4 with double strike.
///
/// Scenario: Alice casts Student of Warfare and activates its level-up ability 7 times
/// during her main phase. At level 7+, the Student becomes a 4/4 with double strike.
#[test]
fn test_student_of_warfare_level_7() {
    use crate::cards::definitions::basic_plains;
    use crate::game_state::StackEntry;
    use crate::mana::ManaSymbol;

    let mut game = setup_game();
    let alice = PlayerId::from_index(0);
    let mut trigger_queue = TriggerQueue::default();
    let mut state = PriorityLoopState::new(2);

    // Set up game in main phase with priority
    game.turn.phase = Phase::FirstMain;
    game.turn.step = None;
    game.turn.active_player = alice;
    game.turn.priority_player = Some(alice);

    // Create 8 Plains for mana (1 for casting, 7 for level-ups)
    let plains = basic_plains();
    let mut plains_ids = Vec::new();
    for _ in 0..8 {
        let plains_id = game.create_object_from_definition(&plains, alice, Zone::Battlefield);
        game.remove_summoning_sickness(plains_id);
        plains_ids.push(plains_id);
    }

    let def = student_of_warfare();
    let student_in_hand = game.create_object_from_definition(&def, alice, Zone::Hand);

    // Cast Student of Warfare (costs {W})
    game.tap(plains_ids[0]);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .add(ManaSymbol::White, 1);

    let stack_student_id = game.move_object(student_in_hand, Zone::Stack).unwrap();
    let entry = StackEntry::new(stack_student_id, alice);
    game.push_to_stack(entry);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .remove(ManaSymbol::White, 1);

    resolve_stack_entry(&mut game).expect("Student should resolve");

    // Find the Student on battlefield
    let student_id = game
        .battlefield
        .iter()
        .filter_map(|&id| game.object(id))
        .find(|obj| obj.name == "Student of Warfare" && obj.controller == alice)
        .map(|obj| obj.id)
        .expect("Student should be on battlefield");

    // Level-up 7 times
    for i in 0..7 {
        game.tap(plains_ids[i + 1]);
        game.player_mut(alice)
            .unwrap()
            .mana_pool
            .add(ManaSymbol::White, 1);

        let activate_action = LegalAction::ActivateAbility {
            source: student_id,
            ability_index: 0,
        };
        let response = PriorityResponse::PriorityAction(activate_action);
        let _progress =
            apply_priority_response(&mut game, &mut trigger_queue, &mut state, &response)
                .expect("Level-up activation should succeed");

        resolve_stack_entry(&mut game).expect("Level-up should resolve");
    }

    // Verify 7 level counters
    assert_eq!(
        game.object(student_id)
            .unwrap()
            .counters
            .get(&CounterType::Level),
        Some(&7),
        "Student should have 7 level counters"
    );

    // At level 7+: 4/4 with double strike
    assert_eq!(
        game.calculated_power(student_id),
        Some(4),
        "Student at level 7 should be 4/4"
    );
    assert_eq!(
        game.calculated_toughness(student_id),
        Some(4),
        "Student at level 7 should be 4/4"
    );
    assert!(
        game.object_has_ability(student_id, &StaticAbility::double_strike()),
        "Student at level 7 should have double strike"
    );
    // Note: Double strike doesn't grant first strike, they're separate abilities
}

/// Tests Humility vs leveled Student of Warfare when Humility enters first.
///
/// Scenario: Humility enters the battlefield first. Then Student of Warfare
/// enters with 7 level counters (would normally be 4/4 with double strike).
///
/// Expected behavior:
/// - Layer 6: Humility removes all abilities (including level abilities)
/// - Layer 7b: Humility sets P/T to 1/1
/// - Level effects don't apply because level ability was removed
/// - Result: 1/1 with no abilities
#[test]
fn test_humility_vs_leveled_student_humility_first() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create Humility first using the proper card definition (earlier timestamp)
    let humility_def = humility();
    let _humility_id = game.create_object_from_definition(&humility_def, alice, Zone::Battlefield);

    // Create Student of Warfare second (later timestamp)
    let def = student_of_warfare();
    let student_id = game.create_object_from_definition(&def, alice, Zone::Battlefield);

    // Add 7 level counters (would normally be 4/4 with double strike)
    game.object_mut(student_id)
        .unwrap()
        .add_counters(CounterType::Level, 7);

    // Humility's "lose all abilities" removes the LevelAbilities static ability
    // This creates a dependency - level effects depend on Humility
    // Humility applies first (depended-on), removing level abilities
    // Then Humility's 1/1 setting applies in Layer 7b
    // Result: 1/1 with no abilities
    assert_eq!(
        game.calculated_power(student_id),
        Some(1),
        "Student under Humility should be 1/1 (dependency: Humility removes level ability)"
    );
    assert_eq!(
        game.calculated_toughness(student_id),
        Some(1),
        "Student under Humility should be 1/1"
    );
    assert!(
        !game.object_has_ability(student_id, &StaticAbility::double_strike()),
        "Student under Humility should have no abilities"
    );
    assert!(
        !game.object_has_ability(student_id, &StaticAbility::first_strike()),
        "Student under Humility should have no abilities"
    );
}

/// Tests Humility vs leveled Student of Warfare when Student enters first.
///
/// Scenario: Student of Warfare enters with 7 level counters (4/4 with double strike).
/// Then Humility enters the battlefield.
///
/// Expected behavior:
/// - Even though Student entered first, dependency rules apply
/// - Humility's "lose all abilities" removes the level ability
/// - Humility applies first (depended-on), so level effects cease
/// - Result: 1/1 with no abilities
#[test]
fn test_humility_vs_leveled_student_student_first() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create Student of Warfare first (earlier timestamp)
    let def = student_of_warfare();
    let student_id = game.create_object_from_definition(&def, alice, Zone::Battlefield);

    // Add 7 level counters
    game.object_mut(student_id)
        .unwrap()
        .add_counters(CounterType::Level, 7);

    // Create Humility second using the proper card definition (later timestamp)
    let humility_def = humility();
    let _humility_id = game.create_object_from_definition(&humility_def, alice, Zone::Battlefield);

    // Even though Student entered first, dependency rules apply:
    // - Level symbol's effects depend on Humility's "lose all abilities"
    // - Humility applies first (it's depended on)
    // - Level symbol is removed, so its effects cease to exist
    // - Result: 1/1 with no abilities
    assert_eq!(
        game.calculated_power(student_id),
        Some(1),
        "Student under Humility should be 1/1 regardless of timestamp (dependency)"
    );
    assert_eq!(
        game.calculated_toughness(student_id),
        Some(1),
        "Student under Humility should be 1/1"
    );
    assert!(
        !game.object_has_ability(student_id, &StaticAbility::double_strike()),
        "Student under Humility should have no abilities"
    );
}

/// Tests Student of Warfare recovers when Humility leaves.
///
/// Scenario: Student of Warfare has 7 level counters. Humility is on the
/// battlefield (Student is 1/1). Then Humility is destroyed/leaves.
///
/// Expected behavior:
/// - While Humility is present: Student is 1/1 with no abilities
/// - After Humility leaves: Student recovers to 4/4 with double strike
///
/// This tests that static ability effects are properly re-evaluated.
#[test]
fn test_humility_removed_student_recovers() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create Student with 7 level counters
    let def = student_of_warfare();
    let student_id = game.create_object_from_definition(&def, alice, Zone::Battlefield);
    game.object_mut(student_id)
        .unwrap()
        .add_counters(CounterType::Level, 7);

    // Create Humility using the proper card definition
    let humility_def = humility();
    let humility_id = game.create_object_from_definition(&humility_def, alice, Zone::Battlefield);

    // Verify Student is 1/1 under Humility
    assert_eq!(
        game.calculated_power(student_id),
        Some(1),
        "Student under Humility should be 1/1"
    );

    // Remove Humility (move to graveyard)
    // Note: Static ability effects are generated dynamically by scanning the battlefield,
    // so when Humility leaves, its effects automatically stop applying
    game.move_object(humility_id, Zone::Graveyard);

    // Student should recover its level 7+ stats
    assert_eq!(
        game.calculated_power(student_id),
        Some(4),
        "Student should recover to 4/4 after Humility leaves"
    );
    assert_eq!(
        game.calculated_toughness(student_id),
        Some(4),
        "Student should recover to 4/4 after Humility leaves"
    );
    assert!(
        game.object_has_ability(student_id, &StaticAbility::double_strike()),
        "Student should recover double strike after Humility leaves"
    );
}

/// Test: Turn to Frog P/T setting vs leveled Student of Warfare.
///
/// Scenario: Student of Warfare has 7 level counters (normally 4/4 with double strike).
/// Turn to Frog effect sets its P/T to 1/1 in Layer 7b. Both the level ability and
/// Turn to Frog operate in Layer 7b (Setting sublayer), so timestamp ordering applies.
/// Turn to Frog has a later timestamp, so it wins and the creature is 1/1. However,
/// this version of Turn to Frog does NOT remove abilities, so the Student retains
/// double strike.
///
/// Note: This test uses direct ContinuousEffect creation because it's testing
/// timestamp interaction between level abilities and "set P/T" effects in Layer 7b.
#[test]
fn test_turn_to_frog_vs_leveled_student() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create Student with 7 level counters (normally 4/4)
    let def = student_of_warfare();
    let student_id = game.create_object_from_definition(&def, alice, Zone::Battlefield);
    game.object_mut(student_id)
        .unwrap()
        .add_counters(CounterType::Level, 7);

    // Apply Turn to Frog effect (just the P/T setting, not ability removal)
    let source = game.new_object_id();
    let turn_to_frog = ContinuousEffect::new(
        source,
        alice,
        EffectTarget::Specific(student_id),
        Modification::SetPowerToughness {
            power: Value::Fixed(1),
            toughness: Value::Fixed(1),
            sublayer: PtSublayer::Setting,
        },
    )
    .until(Until::EndOfTurn);
    game.continuous_effects.add_effect(turn_to_frog);

    // Level symbol sets P/T in 7b (timestamp when Student entered)
    // Turn to Frog sets P/T in 7b (later timestamp)
    // Later timestamp wins: 1/1
    // But abilities are NOT removed, so Student still has double strike
    assert_eq!(
        game.calculated_power(student_id),
        Some(1),
        "Turn to Frog should override level P/T (later timestamp in 7b)"
    );
    assert_eq!(
        game.calculated_toughness(student_id),
        Some(1),
        "Turn to Frog should override level P/T"
    );
    assert!(
        game.object_has_ability(student_id, &StaticAbility::double_strike()),
        "Student should still have double strike (Turn to Frog doesn't remove abilities)"
    );
}

/// Test: Giant Growth on a leveled Student of Warfare.
///
/// Scenario: Alice casts Student of Warfare, activates level-up twice to reach level 2
/// (making it 3/3 with first strike), then casts Giant Growth targeting it. The layer
/// system applies level P/T in layer 7b (setting) and Giant Growth in layer 7c (modifying).
/// Final result is 6/6 with first strike.
#[test]
fn test_giant_growth_on_leveled_student() {
    use crate::cards::definitions::{basic_forest, basic_plains, giant_growth};
    use crate::game_state::StackEntry;
    use crate::mana::ManaSymbol;

    let mut game = setup_game();
    let alice = PlayerId::from_index(0);
    let mut trigger_queue = TriggerQueue::default();
    let mut state = PriorityLoopState::new(2);

    // Set up game in main phase with priority
    game.turn.phase = Phase::FirstMain;
    game.turn.step = None;
    game.turn.active_player = alice;
    game.turn.priority_player = Some(alice);

    // Create 3 Plains (1 for casting student, 2 for level-ups) and 1 Forest (for Giant Growth)
    let plains = basic_plains();
    let plains1_id = game.create_object_from_definition(&plains, alice, Zone::Battlefield);
    let plains2_id = game.create_object_from_definition(&plains, alice, Zone::Battlefield);
    let plains3_id = game.create_object_from_definition(&plains, alice, Zone::Battlefield);
    let forest = basic_forest();
    let forest_id = game.create_object_from_definition(&forest, alice, Zone::Battlefield);
    game.remove_summoning_sickness(plains1_id);
    game.remove_summoning_sickness(plains2_id);
    game.remove_summoning_sickness(plains3_id);
    game.remove_summoning_sickness(forest_id);

    // Create Student and Giant Growth in hand
    let def = student_of_warfare();
    let student_in_hand = game.create_object_from_definition(&def, alice, Zone::Hand);
    let gg_def = giant_growth();
    let gg_in_hand = game.create_object_from_definition(&gg_def, alice, Zone::Hand);

    // Cast Student of Warfare (costs {W})
    game.tap(plains1_id);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .add(ManaSymbol::White, 1);

    let stack_student_id = game.move_object(student_in_hand, Zone::Stack).unwrap();
    let entry = StackEntry::new(stack_student_id, alice);
    game.push_to_stack(entry);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .remove(ManaSymbol::White, 1);

    resolve_stack_entry(&mut game).expect("Student should resolve");

    // Find the Student on battlefield
    let student_id = game
        .battlefield
        .iter()
        .filter_map(|&id| game.object(id))
        .find(|obj| obj.name == "Student of Warfare" && obj.controller == alice)
        .map(|obj| obj.id)
        .expect("Student should be on battlefield");

    // Level-up twice to reach level 2
    for plains_id in [plains2_id, plains3_id] {
        game.tap(plains_id);
        game.player_mut(alice)
            .unwrap()
            .mana_pool
            .add(ManaSymbol::White, 1);

        let activate_action = LegalAction::ActivateAbility {
            source: student_id,
            ability_index: 0,
        };
        let response = PriorityResponse::PriorityAction(activate_action);
        apply_priority_response(&mut game, &mut trigger_queue, &mut state, &response)
            .expect("Level-up should succeed");

        resolve_stack_entry(&mut game).expect("Level-up should resolve");
    }

    // Verify level 2 stats before Giant Growth
    assert_eq!(
        game.calculated_power(student_id),
        Some(3),
        "Student at level 2 should be 3/3"
    );

    // Cast Giant Growth targeting the Student
    game.tap(forest_id);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .add(ManaSymbol::Green, 1);

    let stack_gg_id = game.move_object(gg_in_hand, Zone::Stack).unwrap();
    let entry = StackEntry::new(stack_gg_id, alice)
        .with_targets(vec![crate::game_state::Target::Object(student_id)]);
    game.push_to_stack(entry);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .remove(ManaSymbol::Green, 1);

    // Resolve Giant Growth
    resolve_stack_entry(&mut game).expect("Giant Growth should resolve");

    // Layer 7b: Level sets to 3/3
    // Layer 7c: Giant Growth adds +3/+3
    // Result: 6/6
    assert_eq!(
        game.calculated_power(student_id),
        Some(6),
        "Level 2 Student (3/3) + Giant Growth (+3/+3) should be 6/6"
    );
    assert_eq!(
        game.calculated_toughness(student_id),
        Some(6),
        "Level 2 Student + Giant Growth should be 6/6"
    );
    assert!(
        game.object_has_ability(student_id, &StaticAbility::first_strike()),
        "Student should still have first strike from level 2"
    );
}

/// Test: +1/+1 counters on a leveled Student of Warfare.
///
/// Scenario: Alice casts Student of Warfare and levels it up to 7 (making it 4/4 with
/// double strike). Then she puts +1/+1 counters on it through a game effect. The layer
/// system applies level P/T in layer 7b and counters in layer 7d. Final result is 6/6.
#[test]
fn test_counters_on_leveled_student() {
    use crate::cards::definitions::basic_plains;
    use crate::effect::Effect;
    use crate::game_state::StackEntry;
    use crate::mana::ManaSymbol;
    use crate::target::ChooseSpec;

    let mut game = setup_game();
    let alice = PlayerId::from_index(0);
    let mut trigger_queue = TriggerQueue::default();
    let mut state = PriorityLoopState::new(2);

    // Set up game in main phase with priority
    game.turn.phase = Phase::FirstMain;
    game.turn.step = None;
    game.turn.active_player = alice;
    game.turn.priority_player = Some(alice);

    // Create 8 Plains for mana (1 for casting, 7 for level-ups)
    let plains = basic_plains();
    let mut plains_ids = Vec::new();
    for _ in 0..8 {
        let plains_id = game.create_object_from_definition(&plains, alice, Zone::Battlefield);
        game.remove_summoning_sickness(plains_id);
        plains_ids.push(plains_id);
    }

    let def = student_of_warfare();
    let student_in_hand = game.create_object_from_definition(&def, alice, Zone::Hand);

    // Cast Student of Warfare (costs {W})
    game.tap(plains_ids[0]);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .add(ManaSymbol::White, 1);

    let stack_student_id = game.move_object(student_in_hand, Zone::Stack).unwrap();
    let entry = StackEntry::new(stack_student_id, alice);
    game.push_to_stack(entry);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .remove(ManaSymbol::White, 1);

    resolve_stack_entry(&mut game).expect("Student should resolve");

    // Find the Student on battlefield
    let student_id = game
        .battlefield
        .iter()
        .filter_map(|&id| game.object(id))
        .find(|obj| obj.name == "Student of Warfare" && obj.controller == alice)
        .map(|obj| obj.id)
        .expect("Student should be on battlefield");

    // Level-up 7 times to reach level 7
    for i in 0..7 {
        game.tap(plains_ids[i + 1]);
        game.player_mut(alice)
            .unwrap()
            .mana_pool
            .add(ManaSymbol::White, 1);

        let activate_action = LegalAction::ActivateAbility {
            source: student_id,
            ability_index: 0,
        };
        let response = PriorityResponse::PriorityAction(activate_action);
        apply_priority_response(&mut game, &mut trigger_queue, &mut state, &response)
            .expect("Level-up should succeed");

        resolve_stack_entry(&mut game).expect("Level-up should resolve");
    }

    // Verify level 7 stats (4/4)
    assert_eq!(
        game.calculated_power(student_id),
        Some(4),
        "Student at level 7 should be 4/4"
    );

    // Create an ability that puts 2 +1/+1 counters on the student
    // This simulates an effect like "Put two +1/+1 counters on target creature"
    let counter_effect = Effect::plus_one_counters(2, ChooseSpec::creature());

    // Create a stack entry for this ability effect
    let entry = StackEntry::ability(student_id, alice, vec![counter_effect])
        .with_targets(vec![crate::game_state::Target::Object(student_id)]);
    game.push_to_stack(entry);

    // Resolve the counter-adding ability
    resolve_stack_entry(&mut game).expect("Counter effect should resolve");

    // Verify 2 +1/+1 counters were added
    assert_eq!(
        game.object(student_id)
            .unwrap()
            .counters
            .get(&CounterType::PlusOnePlusOne),
        Some(&2),
        "Student should have 2 +1/+1 counters"
    );

    // Layer 7b: Level sets to 4/4
    // Layer 7d: +1/+1 counters add +2/+2
    // Result: 6/6
    assert_eq!(
        game.calculated_power(student_id),
        Some(6),
        "Level 7 Student (4/4) + 2 +1/+1 counters should be 6/6"
    );
    assert_eq!(
        game.calculated_toughness(student_id),
        Some(6),
        "Level 7 Student + counters should be 6/6"
    );
}

/// Tests Humility + Giant Growth on leveled Student of Warfare.
///
/// Scenario: Student of Warfare has 7 level counters. Humility is on the
/// battlefield. Giant Growth is cast on Student.
///
/// Expected behavior:
/// - Layer 6: Humility removes all abilities (including level abilities)
/// - Layer 7b: Humility sets P/T to 1/1
/// - Layer 7c: Giant Growth adds +3/+3
/// - Result: 4/4 with no abilities
#[test]
fn test_humility_plus_giant_growth_on_student() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create Student with 7 level counters
    let def = student_of_warfare();
    let student_id = game.create_object_from_definition(&def, alice, Zone::Battlefield);
    game.object_mut(student_id)
        .unwrap()
        .add_counters(CounterType::Level, 7);

    // Create Humility using the proper card definition
    let humility_def = humility();
    let _humility_id = game.create_object_from_definition(&humility_def, alice, Zone::Battlefield);

    // Apply Giant Growth effect (this would normally come from resolving Giant Growth spell)
    let source = game.new_object_id();
    let giant_growth = ContinuousEffect::new(
        source,
        alice,
        EffectTarget::Specific(student_id),
        Modification::ModifyPowerToughness {
            power: 3,
            toughness: 3,
        },
    )
    .until(Until::EndOfTurn);
    game.continuous_effects.add_effect(giant_growth);

    // Layer 6: Humility removes all abilities (including level symbol)
    // Layer 7b: Humility sets to 1/1 (level's 7b effect doesn't exist anymore)
    // Layer 7c: Giant Growth adds +3/+3
    // Result: 4/4 with no abilities
    assert_eq!(
        game.calculated_power(student_id),
        Some(4),
        "Humility (1/1) + Giant Growth (+3/+3) should be 4/4"
    );
    assert_eq!(
        game.calculated_toughness(student_id),
        Some(4),
        "Humility + Giant Growth should be 4/4"
    );
    assert!(
        !game.object_has_ability(student_id, &StaticAbility::double_strike()),
        "Student under Humility should have no abilities"
    );
}

// =============================================================================
// Yawgmoth + Undying Combo Tests
// =============================================================================
//
// This tests the famous Yawgmoth, Thran Physician + two undying creatures combo:
// 1. Sacrifice Creature A (no +1/+1 counters) to Yawgmoth
// 2. Creature A dies, Undying triggers, returns with +1/+1 counter
// 3. Yawgmoth puts -1/-1 counter on Creature B (which has a +1/+1 counter)
// 4. State-based actions: +1/+1 and -1/-1 counters annihilate on Creature B
// 5. Now Creature B has no counters, so if it dies, Undying triggers again
// 6. Repeat, losing 1 life and drawing 1 card each iteration
//
// This loop continues until the player has no life remaining.

use crate::cards::definitions::{butcher_ghoul, sightless_ghoul, yawgmoth_thran_physician};
use crate::decision::{AutoPassDecisionMaker, LegalAction};
use crate::game_loop::{
    PriorityLoopState, PriorityResponse, apply_priority_response, apply_priority_response_with_dm,
    check_and_apply_sbas_with, put_triggers_on_stack, resolve_stack_entry,
};

/// Test: Undying creature returns from the graveyard with a +1/+1 counter.
///
/// Scenario: Alice controls a Butcher Ghoul (1/1 with undying) and casts Lightning Bolt
/// on it. The bolt deals 3 damage, killing the ghoul. Since the ghoul had no +1/+1 counters,
/// undying triggers and returns it to the battlefield with a +1/+1 counter.
#[test]
fn test_undying_creature_returns_with_plus_counter() {
    use crate::cards::definitions::{basic_mountain, lightning_bolt};
    use crate::game_state::StackEntry;
    use crate::mana::ManaSymbol;

    let mut game = setup_game();
    let alice = PlayerId::from_index(0);
    let mut trigger_queue = TriggerQueue::default();

    // Set up game in main phase with priority
    game.turn.phase = Phase::FirstMain;
    game.turn.step = None;
    game.turn.active_player = alice;
    game.turn.priority_player = Some(alice);

    // Create Butcher Ghoul (1/1 Zombie with undying)
    let def = butcher_ghoul();
    let ghoul_id = game.create_object_from_definition(&def, alice, Zone::Battlefield);

    // Verify it has no counters initially
    assert_eq!(
        game.object(ghoul_id)
            .unwrap()
            .counters
            .get(&CounterType::PlusOnePlusOne),
        None,
        "Butcher Ghoul should start with no +1/+1 counters"
    );

    // Create Mountain for mana and Lightning Bolt in hand
    let mountain = basic_mountain();
    let mountain_id = game.create_object_from_definition(&mountain, alice, Zone::Battlefield);
    game.remove_summoning_sickness(mountain_id);

    let bolt = lightning_bolt();
    let bolt_id = game.create_object_from_definition(&bolt, alice, Zone::Hand);

    // Tap mountain for red mana
    game.tap(mountain_id);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .add(ManaSymbol::Red, 1);

    // Cast Lightning Bolt targeting the Butcher Ghoul
    let stack_bolt_id = game.move_object(bolt_id, Zone::Stack).unwrap();
    let entry = StackEntry::new(stack_bolt_id, alice)
        .with_targets(vec![crate::game_state::Target::Object(ghoul_id)]);
    game.push_to_stack(entry);

    // Pay the mana cost
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .remove(ManaSymbol::Red, 1);

    // Resolve Lightning Bolt - deals 3 damage to the ghoul
    resolve_stack_entry(&mut game).expect("Lightning Bolt should resolve");

    // Verify the ghoul took lethal damage (3 damage on a 1/1)
    assert_eq!(
        game.damage_on(ghoul_id),
        3,
        "Ghoul should have 3 damage marked"
    );

    // Apply SBAs - creature dies from lethal damage, undying triggers
    check_and_apply_sbas_with(&mut game, &mut trigger_queue, &mut AutoPassDecisionMaker)
        .expect("SBAs should apply cleanly");

    // Put undying trigger on the stack
    put_triggers_on_stack(&mut game, &mut trigger_queue).expect("Should put triggers on stack");

    // Verify undying trigger is on the stack
    assert!(
        !game.stack_is_empty(),
        "Undying trigger should be on the stack"
    );

    // Resolve undying trigger - creature returns with +1/+1 counter
    resolve_stack_entry(&mut game).expect("Undying trigger should resolve");

    // Find the returned creature (it has a new ID after zone change)
    let returned_id = game
        .battlefield
        .iter()
        .filter_map(|&id| game.object(id))
        .find(|obj| obj.name == "Butcher Ghoul" && obj.controller == alice)
        .map(|obj| obj.id)
        .expect("Butcher Ghoul should have returned to the battlefield");

    // Verify the creature returned with a +1/+1 counter
    assert_eq!(
        game.object(returned_id)
            .unwrap()
            .counters
            .get(&CounterType::PlusOnePlusOne),
        Some(&1),
        "Returned creature should have a +1/+1 counter"
    );

    // Verify it's on the battlefield
    assert!(
        game.battlefield.contains(&returned_id),
        "Creature should be on battlefield"
    );
}

/// Test: Undying does NOT trigger when the creature has a +1/+1 counter.
///
/// Scenario: Alice controls a Butcher Ghoul that already has a +1/+1 counter (simulating
/// it had previously returned via undying). Alice casts Lightning Bolt on it, dealing
/// 3 damage to the 2/2 creature (lethal damage). Since the ghoul has a +1/+1 counter
/// when it dies, undying does NOT trigger and the creature stays in the graveyard.
#[test]
fn test_undying_does_not_trigger_with_plus_counter_integration() {
    use crate::cards::definitions::{basic_mountain, lightning_bolt};
    use crate::game_state::StackEntry;
    use crate::mana::ManaSymbol;

    let mut game = setup_game();
    let alice = PlayerId::from_index(0);
    let mut trigger_queue = TriggerQueue::default();

    // Set up game in main phase with priority
    game.turn.phase = Phase::FirstMain;
    game.turn.step = None;
    game.turn.active_player = alice;
    game.turn.priority_player = Some(alice);

    // Create Butcher Ghoul with a +1/+1 counter already on it (simulating previous undying return)
    // This makes it a 2/2
    let def = butcher_ghoul();
    let ghoul_id = game.create_object_from_definition(&def, alice, Zone::Battlefield);
    game.object_mut(ghoul_id)
        .unwrap()
        .add_counters(CounterType::PlusOnePlusOne, 1);

    // Verify it has the +1/+1 counter and is a 2/2
    assert_eq!(
        game.object(ghoul_id)
            .unwrap()
            .counters
            .get(&CounterType::PlusOnePlusOne),
        Some(&1),
        "Butcher Ghoul should have a +1/+1 counter"
    );
    assert_eq!(
        game.calculated_toughness(ghoul_id),
        Some(2),
        "Butcher Ghoul with +1/+1 counter should be a 2/2"
    );

    // Create Mountain and Lightning Bolt
    let mountain = basic_mountain();
    let mountain_id = game.create_object_from_definition(&mountain, alice, Zone::Battlefield);
    game.remove_summoning_sickness(mountain_id);

    let bolt = lightning_bolt();
    let bolt_id = game.create_object_from_definition(&bolt, alice, Zone::Hand);

    // Tap mountain for red mana
    game.tap(mountain_id);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .add(ManaSymbol::Red, 1);

    // Cast Lightning Bolt targeting the Butcher Ghoul
    let stack_bolt_id = game.move_object(bolt_id, Zone::Stack).unwrap();
    let entry = StackEntry::new(stack_bolt_id, alice)
        .with_targets(vec![crate::game_state::Target::Object(ghoul_id)]);
    game.push_to_stack(entry);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .remove(ManaSymbol::Red, 1);

    // Resolve Lightning Bolt - deals 3 damage to the 2/2 ghoul (lethal)
    resolve_stack_entry(&mut game).expect("Lightning Bolt should resolve");

    // Apply SBAs - creature dies from lethal damage
    check_and_apply_sbas_with(&mut game, &mut trigger_queue, &mut AutoPassDecisionMaker)
        .expect("SBAs should apply cleanly");

    // Ghoul should be dead (moved to graveyard)
    assert!(
        !game.battlefield.contains(&ghoul_id),
        "Ghoul should have died from 3 damage (it was a 2/2)"
    );

    // Put any triggers on stack - undying should NOT trigger
    put_triggers_on_stack(&mut game, &mut trigger_queue).expect("Should put triggers on stack");

    // Stack should be empty - undying shouldn't trigger because creature had +1/+1 counter
    assert!(
        game.stack_is_empty(),
        "Undying should NOT trigger when creature has +1/+1 counter"
    );

    // Verify ghoul is in graveyard and stays there
    let ghoul_in_graveyard = game.player(alice).unwrap().graveyard.iter().any(|&id| {
        game.object(id)
            .map(|o| o.name == "Butcher Ghoul")
            .unwrap_or(false)
    });
    assert!(
        ghoul_in_graveyard,
        "Ghoul should stay in graveyard (undying didn't trigger)"
    );

    // Verify no creature named Butcher Ghoul is on battlefield
    let ghoul_on_battlefield = game.battlefield.iter().any(|&id| {
        game.object(id)
            .map(|o| o.name == "Butcher Ghoul")
            .unwrap_or(false)
    });
    assert!(
        !ghoul_on_battlefield,
        "Ghoul should NOT have returned to battlefield"
    );
}

/// Test: Counter annihilation enables undying to trigger again.
///
/// Scenario: This tests the core of the Yawgmoth combo. Alice has Yawgmoth, Sightless Ghoul
/// (no counters), and Butcher Ghoul (with +1/+1 counter from previous undying trigger).
/// Alice activates Yawgmoth, sacrificing Sightless Ghoul and targeting Butcher Ghoul with
/// the -1/-1 counter. After SBAs, the +1/+1 and -1/-1 counters annihilate each other.
/// Now when Butcher Ghoul is killed later, undying can trigger again since it has no
/// +1/+1 counter.
#[test]
fn test_counter_annihilation_enables_undying_loop() {
    use crate::cards::definitions::{basic_mountain, lightning_bolt};
    use crate::game_state::StackEntry;
    use crate::mana::ManaSymbol;

    let mut game = setup_game();
    let alice = PlayerId::from_index(0);
    let mut trigger_queue = TriggerQueue::default();

    // Set up game in main phase with priority
    game.turn.phase = Phase::FirstMain;
    game.turn.step = None;
    game.turn.active_player = alice;
    game.turn.priority_player = Some(alice);

    // Put cards in library so we can draw
    for i in 0..5 {
        let card = CardBuilder::new(CardId::new(), &format!("Test Card {}", i))
            .card_types(vec![CardType::Instant])
            .build();
        game.create_object_from_card(&card, alice, Zone::Library);
    }

    // Create Yawgmoth
    let yawgmoth_def = yawgmoth_thran_physician();
    let yawgmoth_id = game.create_object_from_definition(&yawgmoth_def, alice, Zone::Battlefield);

    // Create Sightless Ghoul (will be sacrificed)
    let sightless_def = sightless_ghoul();
    let _sightless_id =
        game.create_object_from_definition(&sightless_def, alice, Zone::Battlefield);

    // Create Butcher Ghoul with a +1/+1 counter (simulating it already came back once)
    let butcher_def = butcher_ghoul();
    let butcher_id = game.create_object_from_definition(&butcher_def, alice, Zone::Battlefield);
    game.object_mut(butcher_id)
        .unwrap()
        .add_counters(CounterType::PlusOnePlusOne, 1);

    // Verify Butcher Ghoul has the +1/+1 counter
    assert_eq!(
        game.object(butcher_id)
            .unwrap()
            .counters
            .get(&CounterType::PlusOnePlusOne),
        Some(&1),
        "Butcher Ghoul should have +1/+1 counter"
    );

    // Create a priority loop state and decision maker
    let mut state = PriorityLoopState::new(2);
    let mut decision_maker = AutoPassDecisionMaker;

    // Activate Yawgmoth's sacrifice ability (ability index 1, after Protection static ability)
    let activate_action = LegalAction::ActivateAbility {
        source: yawgmoth_id,
        ability_index: 1,
    };

    let response = PriorityResponse::PriorityAction(activate_action);
    let progress = apply_priority_response_with_dm(
        &mut game,
        &mut trigger_queue,
        &mut state,
        &response,
        &mut decision_maker,
    )
    .expect("Activation should start");
    let _progress = match progress {
        crate::decision::GameProgress::NeedsDecisionCtx(
            crate::decisions::context::DecisionContext::Targets(_),
        ) => {
            let response =
                PriorityResponse::Targets(vec![crate::game_state::Target::Object(butcher_id)]);
            apply_priority_response_with_dm(
                &mut game,
                &mut trigger_queue,
                &mut state,
                &response,
                &mut decision_maker,
            )
            .expect("Target selection should succeed")
        }
        other => panic!("Expected Targets context but got {:?}", other),
    };

    // After targeting, cost_effects execute automatically:
    // - ChooseObjectsEffect selects Sightless Ghoul (first valid candidate in battlefield order)
    // - SacrificeEffect sacrifices it
    //
    // At this point:
    // - Sightless Ghoul was sacrificed (moved to graveyard, undying trigger queued)
    // - 1 life was paid
    // - Yawgmoth's ability is on the stack
    // - Undying trigger has been moved to the stack by advance_priority
    //
    // Stack should have: [Yawgmoth's ability, Undying trigger]
    // In LIFO order, we resolve Undying first, then Yawgmoth's ability

    // Both players pass priority to let the stack resolve fully
    // (AutoPassDecisionMaker handles trigger targeting automatically)
    let mut loop_count = 0;
    while !game.stack_is_empty() && loop_count < 20 {
        // Pass priority for active player
        let response = PriorityResponse::PriorityAction(LegalAction::PassPriority);
        let _ = apply_priority_response_with_dm(
            &mut game,
            &mut trigger_queue,
            &mut state,
            &response,
            &mut decision_maker,
        );
        loop_count += 1;
    }

    // Verify stack resolved
    assert!(
        game.stack_is_empty(),
        "Stack should be empty after resolution"
    );

    // Apply SBAs - counters should annihilate
    check_and_apply_sbas_with(&mut game, &mut trigger_queue, &mut AutoPassDecisionMaker)
        .expect("SBAs should apply cleanly");

    // Verify +1/+1 and -1/-1 counters annihilated on Butcher Ghoul
    assert_eq!(
        game.object(butcher_id)
            .unwrap()
            .counters
            .get(&CounterType::PlusOnePlusOne),
        None,
        "+1/+1 counter should be gone after annihilation"
    );
    assert_eq!(
        game.object(butcher_id)
            .unwrap()
            .counters
            .get(&CounterType::MinusOneMinusOne),
        None,
        "-1/-1 counter should be gone after annihilation"
    );

    // Now kill Butcher Ghoul (use Lightning Bolt) - undying should trigger again
    // Create Mountain and Lightning Bolt
    let mountain = basic_mountain();
    let mountain_id = game.create_object_from_definition(&mountain, alice, Zone::Battlefield);
    game.remove_summoning_sickness(mountain_id);

    let bolt = lightning_bolt();
    let bolt_id = game.create_object_from_definition(&bolt, alice, Zone::Hand);

    // Tap mountain for red mana
    game.tap(mountain_id);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .add(ManaSymbol::Red, 1);

    // Cast Lightning Bolt targeting Butcher Ghoul
    let stack_bolt_id = game.move_object(bolt_id, Zone::Stack).unwrap();
    let entry = StackEntry::new(stack_bolt_id, alice)
        .with_targets(vec![crate::game_state::Target::Object(butcher_id)]);
    game.push_to_stack(entry);
    game.player_mut(alice)
        .unwrap()
        .mana_pool
        .remove(ManaSymbol::Red, 1);

    // Resolve Lightning Bolt
    resolve_stack_entry(&mut game).expect("Lightning Bolt should resolve");

    // Apply SBAs - Butcher Ghoul dies, undying triggers
    check_and_apply_sbas_with(&mut game, &mut trigger_queue, &mut AutoPassDecisionMaker)
        .expect("SBAs should apply cleanly");

    // Put undying trigger on stack
    put_triggers_on_stack(&mut game, &mut trigger_queue).expect("Should put triggers on stack");

    // Verify undying trigger is on the stack
    assert!(
        !game.stack_is_empty(),
        "Undying should trigger again after counters annihilated"
    );

    // Resolve undying trigger - Butcher Ghoul returns with +1/+1 counter
    resolve_stack_entry(&mut game).expect("Undying trigger should resolve");

    // Find the returned Butcher Ghoul
    let returned_butcher = game
        .battlefield
        .iter()
        .filter_map(|&id| game.object(id))
        .find(|obj| obj.name == "Butcher Ghoul" && obj.controller == alice)
        .map(|obj| obj.id)
        .expect("Butcher Ghoul should have returned to the battlefield");

    // Verify it returned with a +1/+1 counter
    assert_eq!(
        game.object(returned_butcher)
            .unwrap()
            .counters
            .get(&CounterType::PlusOnePlusOne),
        Some(&1),
        "Returned Butcher Ghoul should have +1/+1 counter from undying"
    );
}

#[test]
fn test_yawgmoth_undying_loop_draws_cards_until_death() {
    // Full combo test: Yawgmoth + Butcher Ghoul + Sightless Ghoul
    // This test uses the game loop machinery to process triggers and SBAs.
    //
    // The combo works as follows:
    // - Start with two undying creatures (A and B) with no counters
    // - Iteration 1: Sacrifice A (no counters), DON'T put -1/-1 anywhere, draw
    //   A returns with +1/+1 counter
    // - Iteration 2: Sacrifice B (no counters), put -1/-1 on A (has +1/+1), draw
    //   B returns with +1/+1 counter
    //   SBA: A's +1/+1 and -1/-1 annihilate, A now has no counters
    // - Iteration 3: Sacrifice A (no counters), put -1/-1 on B (has +1/+1), draw
    //   A returns with +1/+1 counter
    //   SBA: B's counters annihilate
    // - ... repeat forever
    //
    // With cost_effects, the sacrifice target is auto-selected based on battlefield order.
    // The combo works because sacrificed creatures return at the end of the battlefield,
    // so the next iteration auto-selects the OTHER creature (which is earlier in the list).

    let mut game = setup_game();
    let alice = PlayerId::from_index(0);
    let mut trigger_queue = TriggerQueue::default();
    let mut decision_maker = AutoPassDecisionMaker;

    // Set up the player with 10 life for a reasonable test
    game.player_mut(alice).unwrap().life = 10;

    // Set up game state for main phase with priority (so abilities can be activated)
    game.turn.phase = Phase::FirstMain;
    game.turn.step = None;
    game.turn.active_player = alice;
    game.turn.priority_player = Some(alice);

    // Put some cards in library so we can draw
    for i in 0..30 {
        let card = CardBuilder::new(CardId::new(), &format!("Test Card {}", i))
            .card_types(vec![CardType::Instant])
            .build();
        game.create_object_from_card(&card, alice, Zone::Library);
    }

    let initial_hand_size = game.player(alice).unwrap().hand.len();

    // Create Yawgmoth
    let yawgmoth_def = yawgmoth_thran_physician();
    let yawgmoth_id = game.create_object_from_definition(&yawgmoth_def, alice, Zone::Battlefield);

    // Create the two undying creatures
    // Note: Butcher is created first, so it's first in battlefield order.
    // After sacrifice+undying, creatures return at the end of the battlefield,
    // so auto-selection naturally picks the correct creature each time.
    let butcher_def = butcher_ghoul();
    let sightless_def = sightless_ghoul();
    let _butcher_id = game.create_object_from_definition(&butcher_def, alice, Zone::Battlefield);
    let _sightless_id =
        game.create_object_from_definition(&sightless_def, alice, Zone::Battlefield);

    let mut cards_drawn = 0;
    let mut iterations = 0;
    let max_iterations = 20; // Safety limit (should be able to loop until 0 life)

    // Create a priority loop state for tracking activation
    let mut state = PriorityLoopState::new(2);

    while game.player(alice).unwrap().life > 0 && iterations < max_iterations {
        // Find both undying creatures by name (IDs change after undying returns them)
        let undying_creatures: Vec<_> = game
            .battlefield
            .iter()
            .filter_map(|&id| game.object(id))
            .filter(|obj| {
                obj.controller == alice
                    && obj.id != yawgmoth_id
                    && (obj.name == "Butcher Ghoul" || obj.name == "Sightless Ghoul")
            })
            .map(|obj| {
                (
                    obj.id,
                    obj.name.clone(),
                    obj.counters
                        .get(&CounterType::PlusOnePlusOne)
                        .copied()
                        .unwrap_or(0),
                )
            })
            .collect();

        assert_eq!(
            undying_creatures.len(),
            2,
            "Should have exactly 2 undying creatures on battlefield"
        );

        // The first creature in the list will be auto-sacrificed (ChooseObjectsEffect picks first match)
        let (_will_be_sacrificed, _sacrifice_name, _) = &undying_creatures[0];
        let (target_for_counter, _target_name, target_plus_counters) = &undying_creatures[1];

        // === ACTIVATE YAWGMOTH'S ABILITY USING PROPER GAME FLOW ===
        // Cost: Pay 1 life, Sacrifice another creature (via cost_effects)
        // Effect: Put a -1/-1 counter on up to one target creature and draw a card

        // Yawgmoth's sacrifice ability is at index 1 (index 0 is Protection from Humans static ability)
        let activate_action = LegalAction::ActivateAbility {
            source: yawgmoth_id,
            ability_index: 1,
        };

        // Step 1: Initiate activation
        let response = PriorityResponse::PriorityAction(activate_action);
        let progress = apply_priority_response_with_dm(
            &mut game,
            &mut trigger_queue,
            &mut state,
            &response,
            &mut decision_maker,
        )
        .expect("Activation should start");
        let targets = if *target_plus_counters > 0 {
            vec![crate::game_state::Target::Object(*target_for_counter)]
        } else {
            vec![]
        };
        let _progress = match progress {
            crate::decision::GameProgress::NeedsDecisionCtx(
                crate::decisions::context::DecisionContext::Targets(_),
            ) => {
                let response = PriorityResponse::Targets(targets);
                apply_priority_response_with_dm(
                    &mut game,
                    &mut trigger_queue,
                    &mut state,
                    &response,
                    &mut decision_maker,
                )
                .expect("Target selection should succeed")
            }
            other => panic!("Expected Targets context but got {:?}", other),
        };

        // After targeting, cost_effects execute automatically:
        // - ChooseObjectsEffect selects first valid creature (auto-selection)
        // - SacrificeEffect sacrifices it
        // - 1 life is paid
        // - Ability goes on stack
        // - Undying trigger queued (will be moved to stack during priority handling)

        // Both players pass priority to let the stack resolve fully
        // The priority loop handles trigger ordering and stack resolution
        let mut loop_count = 0;
        while !game.stack_is_empty() && loop_count < 20 {
            let response = PriorityResponse::PriorityAction(LegalAction::PassPriority);
            let _ = apply_priority_response_with_dm(
                &mut game,
                &mut trigger_queue,
                &mut state,
                &response,
                &mut decision_maker,
            );
            loop_count += 1;
        }
        assert!(
            game.stack_is_empty(),
            "Stack should be empty after resolution"
        );
        cards_drawn += 1;

        // Untap Yawgmoth for next iteration (his ability doesn't require tapping,
        // but we untap anyway to be safe in case we add tap costs later)
        game.untap(yawgmoth_id);

        // Apply SBAs using the game loop machinery
        // This handles counter annihilation (+1/+1 and -1/-1 cancel out)
        check_and_apply_sbas_with(&mut game, &mut trigger_queue, &mut decision_maker)
            .expect("SBAs should apply cleanly");

        // Any triggers generated by SBAs should be resolved
        if !trigger_queue.is_empty() {
            put_triggers_on_stack(&mut game, &mut trigger_queue)
                .expect("Should put SBA triggers on stack");
            while !game.stack_is_empty() {
                let response = PriorityResponse::PriorityAction(LegalAction::PassPriority);
                let _ = apply_priority_response_with_dm(
                    &mut game,
                    &mut trigger_queue,
                    &mut state,
                    &response,
                    &mut decision_maker,
                );
            }
        }

        iterations += 1;
    }

    // Verify the combo worked
    let final_life = game.player(alice).unwrap().life;
    let final_hand_size = game.player(alice).unwrap().hand.len();

    assert!(
        iterations >= 10,
        "Should have executed at least 10 iterations (started with 10 life), got {}",
        iterations
    );
    assert_eq!(
        cards_drawn, iterations,
        "Should draw one card per iteration"
    );
    assert_eq!(
        final_hand_size,
        initial_hand_size + cards_drawn,
        "Hand size should increase by cards drawn"
    );
    assert_eq!(
        final_life,
        10 - iterations as i32,
        "Should lose 1 life per iteration"
    );
    assert_eq!(final_life, 0, "Loop should continue until death");
}

// =============================================================================
// Must Attack If Able Tests
// =============================================================================
//
// These tests verify that creatures with "attacks each combat if able" (like
// Dauthi Slayer) are properly enforced during the declare attackers step.

/// Tests that a creature with "must attack if able" can be declared as an attacker.
///
/// Scenario: Alice controls Dauthi Slayer (has "attacks each combat if able").
/// Alice declares Dauthi Slayer as an attacker during the declare attackers step.
///
/// Expected behavior:
/// - The declaration succeeds because the must-attack creature is included.
#[test]
fn test_must_attack_creature_can_be_declared() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);
    let bob = PlayerId::from_index(1);

    // Create Dauthi Slayer on the battlefield (has MustAttack static ability)
    let slayer_def = dauthi_slayer();
    let slayer_id = game.create_object_from_definition(&slayer_def, alice, Zone::Battlefield);

    // Make sure it's not summoning sick
    game.remove_summoning_sickness(slayer_id);

    // Set up combat state
    let mut combat = new_combat();
    let mut trigger_queue = TriggerQueue::new();

    // Declare Dauthi Slayer as an attacker
    let declarations = vec![AttackerDeclaration {
        creature: slayer_id,
        target: AttackTarget::Player(bob),
    }];

    // This should succeed
    let result =
        apply_attacker_declarations(&mut game, &mut combat, &mut trigger_queue, &declarations);
    assert!(
        result.is_ok(),
        "Should be able to declare must-attack creature as attacker"
    );

    // Verify it's in the attackers list
    assert_eq!(combat.attackers.len(), 1, "Should have one attacker");
    assert_eq!(
        combat.attackers[0].creature, slayer_id,
        "Dauthi Slayer should be the attacker"
    );
}

/// Tests that failing to declare a "must attack if able" creature returns an error.
///
/// Scenario: Alice controls Dauthi Slayer (has "attacks each combat if able").
/// Alice tries to declare no attackers during the declare attackers step.
///
/// Expected behavior:
/// - The declaration fails with MustAttackNotDeclared error.
/// - The error includes the creature ID of the must-attack creature.
#[test]
fn test_must_attack_creature_not_declared_returns_error() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create Dauthi Slayer on the battlefield (has MustAttack static ability)
    let slayer_def = dauthi_slayer();
    let slayer_id = game.create_object_from_definition(&slayer_def, alice, Zone::Battlefield);

    // Make sure it's not summoning sick
    game.remove_summoning_sickness(slayer_id);

    // Set up combat state
    let mut combat = new_combat();
    let mut trigger_queue = TriggerQueue::new();

    // Try to declare no attackers (Dauthi Slayer should be required)
    let declarations: Vec<AttackerDeclaration> = vec![];

    // This should fail
    let result =
        apply_attacker_declarations(&mut game, &mut combat, &mut trigger_queue, &declarations);
    assert!(
        result.is_err(),
        "Should fail when must-attack creature is not declared"
    );

    // Check that we get the correct error
    match result {
        Err(GameLoopError::CombatError(CombatError::MustAttackNotDeclared(creature_id))) => {
            assert_eq!(
                creature_id, slayer_id,
                "Error should reference the must-attack creature"
            );
        }
        Err(e) => panic!("Expected MustAttackNotDeclared error, got: {:?}", e),
        Ok(()) => panic!("Expected error, got Ok"),
    }
}

/// Tests that a tapped "must attack if able" creature does not need to be declared.
///
/// Scenario: Alice controls a tapped Dauthi Slayer.
/// Alice declares no attackers.
///
/// Expected behavior:
/// - The declaration succeeds because tapped creatures can't attack.
#[test]
fn test_tapped_must_attack_creature_is_exempt() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create Dauthi Slayer on the battlefield
    let slayer_def = dauthi_slayer();
    let slayer_id = game.create_object_from_definition(&slayer_def, alice, Zone::Battlefield);

    // Make sure it's not summoning sick but IS tapped
    game.remove_summoning_sickness(slayer_id);
    game.tap(slayer_id);

    // Set up combat state
    let mut combat = new_combat();
    let mut trigger_queue = TriggerQueue::new();

    // Try to declare no attackers (tapped creature can't attack, so this is OK)
    let declarations: Vec<AttackerDeclaration> = vec![];

    let result =
        apply_attacker_declarations(&mut game, &mut combat, &mut trigger_queue, &declarations);
    assert!(
        result.is_ok(),
        "Should succeed when must-attack creature is tapped and can't attack"
    );
}

/// Tests that a summoning sick "must attack if able" creature does not need to be declared.
///
/// Scenario: Alice controls a summoning sick Dauthi Slayer (just entered the battlefield).
/// Alice declares no attackers.
///
/// Expected behavior:
/// - The declaration succeeds because summoning sick creatures without haste can't attack.
#[test]
fn test_summoning_sick_must_attack_creature_is_exempt() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);

    // Create Dauthi Slayer on the battlefield
    let slayer_def = dauthi_slayer();
    let slayer_id = game.create_object_from_definition(&slayer_def, alice, Zone::Battlefield);

    // Set summoning sick (simulates entering the battlefield this turn)
    // Note: create_object_from_definition doesn't set summoning_sick automatically
    game.set_summoning_sick(slayer_id);

    // Set up combat state
    let mut combat = new_combat();
    let mut trigger_queue = TriggerQueue::new();

    // Try to declare no attackers (summoning sick creature can't attack)
    let declarations: Vec<AttackerDeclaration> = vec![];

    let result =
        apply_attacker_declarations(&mut game, &mut combat, &mut trigger_queue, &declarations);
    assert!(
        result.is_ok(),
        "Should succeed when must-attack creature is summoning sick"
    );
}

/// Tests that multiple must-attack creatures must all be declared.
///
/// Scenario: Alice controls two Dauthi Slayers.
/// Alice declares only one of them as an attacker.
///
/// Expected behavior:
/// - The declaration fails because both must-attack creatures need to be declared.
#[test]
fn test_multiple_must_attack_creatures_all_required() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);
    let bob = PlayerId::from_index(1);

    // Create two Dauthi Slayers on the battlefield
    let slayer_def = dauthi_slayer();
    let slayer1_id = game.create_object_from_definition(&slayer_def, alice, Zone::Battlefield);
    let slayer2_id = game.create_object_from_definition(&slayer_def, alice, Zone::Battlefield);

    // Make sure neither is summoning sick
    game.remove_summoning_sickness(slayer1_id);
    game.remove_summoning_sickness(slayer2_id);

    // Set up combat state
    let mut combat = new_combat();
    let mut trigger_queue = TriggerQueue::new();

    // Declare only the first Slayer (second one is also required)
    let declarations = vec![AttackerDeclaration {
        creature: slayer1_id,
        target: AttackTarget::Player(bob),
    }];

    let result =
        apply_attacker_declarations(&mut game, &mut combat, &mut trigger_queue, &declarations);
    assert!(
        result.is_err(),
        "Should fail when not all must-attack creatures are declared"
    );

    match result {
        Err(GameLoopError::CombatError(CombatError::MustAttackNotDeclared(creature_id))) => {
            assert_eq!(
                creature_id, slayer2_id,
                "Error should reference the second must-attack creature"
            );
        }
        Err(e) => panic!("Expected MustAttackNotDeclared error, got: {:?}", e),
        Ok(()) => panic!("Expected error, got Ok"),
    }
}

/// Tests that non-must-attack creatures are optional alongside must-attack creatures.
///
/// Scenario: Alice controls Dauthi Slayer (must attack) and Grizzly Bears (optional).
/// Alice declares only the Dauthi Slayer.
///
/// Expected behavior:
/// - The declaration succeeds because the must-attack creature is declared.
/// - The optional creature (Grizzly Bears) does not need to be declared.
#[test]
fn test_must_attack_with_optional_creature() {
    let mut game = setup_game();
    let alice = PlayerId::from_index(0);
    let bob = PlayerId::from_index(1);

    // Create Dauthi Slayer (must attack) and Grizzly Bears (optional)
    let slayer_def = dauthi_slayer();
    let bears_def = grizzly_bears();
    let slayer_id = game.create_object_from_definition(&slayer_def, alice, Zone::Battlefield);
    let _bears_id = game.create_object_from_definition(&bears_def, alice, Zone::Battlefield);

    // Make sure neither is summoning sick
    game.remove_summoning_sickness(slayer_id);
    game.remove_summoning_sickness(_bears_id);

    // Set up combat state
    let mut combat = new_combat();
    let mut trigger_queue = TriggerQueue::new();

    // Declare only the Dauthi Slayer (Grizzly Bears is optional)
    let declarations = vec![AttackerDeclaration {
        creature: slayer_id,
        target: AttackTarget::Player(bob),
    }];

    let result =
        apply_attacker_declarations(&mut game, &mut combat, &mut trigger_queue, &declarations);
    assert!(
        result.is_ok(),
        "Should succeed when must-attack creature is declared, even if optional creatures are not"
    );

    // Verify only the Slayer is attacking
    assert_eq!(combat.attackers.len(), 1, "Should have one attacker");
    assert_eq!(
        combat.attackers[0].creature, slayer_id,
        "Dauthi Slayer should be the attacker"
    );
}
