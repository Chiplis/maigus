//! Continuous effect and layer system.
//!
//! MTG uses a layer system (rule 613) to determine how continuous effects
//! interact. Effects are applied in layer order, and within a layer by timestamp.

use std::collections::{HashMap, HashSet};

use crate::ability::{Ability, AbilityKind};
use crate::color::{Color, ColorSet};
use crate::effect::{Until, Value};
use crate::ids::{ObjectId, PlayerId};
use crate::object::{CounterType, Object};
use crate::static_abilities::StaticAbility;
use crate::target::ObjectFilter;
use crate::types::{CardType, Subtype, Supertype};
use crate::zone::Zone;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum DependencySortMode {
    Baseline,
    Heuristic,
}

/// The seven layers in which continuous effects are applied.
/// Per MTG rule 613, effects are applied in this order.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum Layer {
    /// Layer 1: Copy effects
    Copy = 1,

    /// Layer 2: Control-changing effects
    Control = 2,

    /// Layer 3: Text-changing effects
    Text = 3,

    /// Layer 4: Type-changing effects
    Type = 4,

    /// Layer 5: Color-changing effects
    Color = 5,

    /// Layer 6: Ability-adding/removing effects
    Ability = 6,

    /// Layer 7: Power/toughness effects (has sublayers)
    PowerToughness = 7,
}

/// Sublayers within Layer 7 (Power/Toughness).
/// Per MTG rule 613.4, these are applied in order.
///
/// IMPORTANT: Per Rule 613.4c, counters that modify power and/or toughness
/// (like +1/+1 and -1/-1) are part of sublayer 7c, NOT a separate sublayer.
/// Counters are applied in timestamp order along with other 7c effects.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum PtSublayer {
    /// 7a: Characteristic-defining abilities that set P/T
    /// (e.g., Tarmogoyf's "* / *+1")
    CharacteristicDefining = 0,

    /// 7b: Effects that set P/T to specific values
    /// (e.g., "becomes a 3/3 creature")
    Setting = 1,

    /// 7c: Effects that modify P/T (including counters)
    /// Per Rule 613.4c, +1/+1 and -1/-1 counters are applied here
    /// in timestamp order with other modifications like +2/+2 effects.
    Modifying = 2,

    /// 7d: Effects that switch P/T
    /// (e.g., "switch target creature's power and toughness")
    /// Note: This was 7e in older rules but is now 7d per CR 613.4d.
    Switching = 3,
}

/// Distinguishes how a continuous effect was created, which affects how it applies.
///
/// # MTG Rules Context
///
/// Per Rules 611.2c and 611.3a, this distinction matters for determining
/// whether targets are locked at resolution or evaluated dynamically.
///
/// ## Resolution Effects (Rule 611.2c)
///
/// Effects created by resolving spells or abilities have their targets "locked in"
/// at the time they resolve. Even if a filter is part of the effect, it was evaluated
/// once at resolution time.
///
/// ```text
/// Example: "Target creature gets +2/+2 until end of turn"
/// - Target chosen when spell is cast
/// - Effect applies only to that specific creature
/// - If creature leaves battlefield and returns, effect doesn't reapply
/// ```
///
/// ## Static Ability Effects (Rule 611.3a)
///
/// Effects generated by static abilities on permanents apply dynamically.
/// They continuously check their filter and apply to any matching objects.
///
/// ```text
/// Example: "Creatures you control get +1/+1" (Glorious Anthem)
/// - No targets chosen
/// - Effect applies to all creatures you currently control
/// - New creatures you gain control of immediately get the bonus
/// - Creatures that stop being creatures lose the bonus
/// ```
///
/// ## Edge Cases
///
/// Some spells create effects with filters that apply to "all" of something:
/// ```text
/// "Until end of turn, creatures you control get +1/+1"
/// ```
/// Even though this has a filter, it's a Resolution effect - the "creatures you control"
/// was evaluated at resolution time. A creature that enters later won't get the bonus.
#[derive(Debug, Clone, PartialEq, Default)]
pub enum EffectSourceType {
    /// Effect created by a resolving spell or ability (Rule 611.2c).
    /// Targets are locked at resolution time and don't update.
    /// Example: "Target creature gets +2/+2 until end of turn" from a spell.
    Resolution {
        /// The objects that were targeted when the effect resolved.
        /// This effect only applies to these specific objects.
        locked_targets: Vec<ObjectId>,
    },

    /// Effect generated by a static ability (Rule 611.3a).
    /// Applies dynamically to all objects matching its filter.
    /// Example: "Creatures you control get +1/+1" from an anthem.
    #[default]
    StaticAbility,

    /// Effect from a characteristic-defining ability (Rule 604.3).
    /// These define the object's characteristics and are applied in layer 7a.
    /// Example: Tarmogoyf's "* / *+1" power/toughness.
    CharacteristicDefining,

    /// Effect from combat (first strike, double strike damage multipliers).
    /// These are temporary effects created during combat damage steps.
    Combat,

    /// Effect from a copy effect (Rule 707).
    /// These work like static ability effects but are evaluated during layer 1.
    Copy,
}

/// A continuous effect that modifies game state.
#[derive(Debug, Clone, PartialEq)]
pub struct ContinuousEffect {
    /// Unique identifier for this effect
    pub id: ContinuousEffectId,

    /// The source that created this effect
    pub source: ObjectId,

    /// The controller of this effect
    pub controller: PlayerId,

    /// Which objects this effect applies to
    pub applies_to: EffectTarget,

    /// The modification this effect makes
    pub modification: Modification,

    /// When this effect was created (for timestamp ordering)
    pub timestamp: u64,

    /// How long this effect lasts
    pub duration: Until,

    /// Optional condition that must be true for this effect to apply
    pub condition: Option<EffectCondition>,

    /// How this effect was created - affects target locking behavior.
    /// Per Rule 611.2c, resolution effects lock targets; per 611.3a, static effects don't.
    pub source_type: EffectSourceType,
}

/// Unique identifier for a continuous effect.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct ContinuousEffectId(pub u64);

impl ContinuousEffectId {
    pub fn new(id: u64) -> Self {
        Self(id)
    }
}

/// What objects a continuous effect applies to.
#[derive(Debug, Clone, PartialEq)]
pub enum EffectTarget {
    /// Applies to a specific object
    Specific(ObjectId),

    /// Applies to all objects matching a filter
    Filter(ObjectFilter),

    /// Applies to the source itself
    Source,

    /// Applies to all permanents
    AllPermanents,

    /// Applies to all creatures
    AllCreatures,

    /// Applies to whatever creature the source (equipment/aura) is attached to
    /// Used for equipment grants like "Equipped creature has haste"
    AttachedTo(ObjectId),
}

/// The modification a continuous effect makes.
#[derive(Debug, Clone, PartialEq)]
pub enum Modification {
    // === Layer 1: Copy ===
    /// Become a copy of another object
    CopyOf(ObjectId),

    // === Layer 2: Control ===
    /// Change controller to a specific player
    ChangeController(PlayerId),

    // === Layer 3: Text ===
    /// Change text (e.g., "Swamp" becomes "Forest")
    ChangeText { from: String, to: String },

    // === Layer 4: Type ===
    /// Add card types
    AddCardTypes(Vec<CardType>),

    /// Remove card types
    RemoveCardTypes(Vec<CardType>),

    /// Set card types (replacing existing)
    SetCardTypes(Vec<CardType>),

    /// Add subtypes
    AddSubtypes(Vec<Subtype>),

    /// Remove subtypes
    RemoveSubtypes(Vec<Subtype>),

    /// Set subtypes (replacing existing)
    SetSubtypes(Vec<Subtype>),

    /// Add supertypes
    AddSupertypes(Vec<Supertype>),

    /// Remove supertypes
    RemoveSupertypes(Vec<Supertype>),

    /// Remove all creature types
    RemoveAllCreatureTypes,

    // === Layer 5: Color ===
    /// Add colors
    AddColors(ColorSet),

    /// Remove colors
    RemoveColors(ColorSet),

    /// Set colors (replacing existing)
    SetColors(ColorSet),

    /// Make colorless
    MakeColorless,

    // === Layer 6: Ability ===
    /// Add an ability
    AddAbility(StaticAbility),

    /// Add an ability without creating dependency edges against RemoveAllAbilities.
    /// Used for cards like Bello where Gatherer rulings specify timestamp ordering.

    /// Add a generic ability (activated, triggered, static, or mana).
    AddAbilityGeneric(Ability),

    /// Copy activated abilities from objects matching a filter.
    CopyActivatedAbilities {
        filter: ObjectFilter,
        counter: Option<crate::object::CounterType>,
        include_mana: bool,
        exclude_source_name: bool,
        exclude_source_id: bool,
    },

    /// Add "Whenever this creature deals combat damage to a player, draw a card."
    /// Used by Bello, Bard of the Brambles.
    AddCombatDamageDrawAbility,

    /// Remove an ability
    RemoveAbility(StaticAbility),

    /// Remove all abilities
    RemoveAllAbilities,

    /// Grant "can't be blocked"
    CantBeBlocked,

    /// Grant "can't attack"
    CantAttack,

    /// Grant "can't block"
    CantBlock,

    /// Grant "doesn't untap"
    DoesntUntap,

    // === Layer 7: Power/Toughness ===
    /// Set power (7a or 7b depending on source)
    SetPower { value: Value, sublayer: PtSublayer },

    /// Set toughness (7a or 7b depending on source)
    SetToughness { value: Value, sublayer: PtSublayer },

    /// Set both power and toughness
    SetPowerToughness {
        power: Value,
        toughness: Value,
        sublayer: PtSublayer,
    },

    /// Modify power (7c)
    ModifyPower(i32),

    /// Modify toughness (7c)
    ModifyToughness(i32),

    /// Modify both power and toughness (7c) - e.g., +2/+2
    ModifyPowerToughness { power: i32, toughness: i32 },

    /// Switch power and toughness (7e)
    SwitchPowerToughness,
}

impl Modification {
    /// Returns which layer this modification applies in.
    pub fn layer(&self) -> Layer {
        match self {
            Modification::CopyOf(_) => Layer::Copy,

            Modification::ChangeController(_) => Layer::Control,

            Modification::ChangeText { .. } => Layer::Text,

            Modification::AddCardTypes(_)
            | Modification::RemoveCardTypes(_)
            | Modification::SetCardTypes(_)
            | Modification::AddSubtypes(_)
            | Modification::RemoveSubtypes(_)
            | Modification::SetSubtypes(_)
            | Modification::AddSupertypes(_)
            | Modification::RemoveSupertypes(_)
            | Modification::RemoveAllCreatureTypes => Layer::Type,

            Modification::AddColors(_)
            | Modification::RemoveColors(_)
            | Modification::SetColors(_)
            | Modification::MakeColorless => Layer::Color,

            Modification::AddAbility(_)
            | Modification::AddAbilityGeneric(_)
            | Modification::CopyActivatedAbilities { .. }
            | Modification::AddCombatDamageDrawAbility
            | Modification::RemoveAbility(_)
            | Modification::RemoveAllAbilities
            | Modification::CantBeBlocked
            | Modification::CantAttack
            | Modification::CantBlock
            | Modification::DoesntUntap => Layer::Ability,

            Modification::SetPower { .. }
            | Modification::SetToughness { .. }
            | Modification::SetPowerToughness { .. }
            | Modification::ModifyPower(_)
            | Modification::ModifyToughness(_)
            | Modification::ModifyPowerToughness { .. }
            | Modification::SwitchPowerToughness => Layer::PowerToughness,
        }
    }

    /// Returns which sublayer this modification applies in (for Layer 7 only).
    pub fn pt_sublayer(&self) -> Option<PtSublayer> {
        match self {
            Modification::SetPower { sublayer, .. }
            | Modification::SetToughness { sublayer, .. }
            | Modification::SetPowerToughness { sublayer, .. } => Some(*sublayer),

            Modification::ModifyPower(_)
            | Modification::ModifyToughness(_)
            | Modification::ModifyPowerToughness { .. } => Some(PtSublayer::Modifying),

            Modification::SwitchPowerToughness => Some(PtSublayer::Switching),

            _ => None,
        }
    }
}

/// A condition for when an effect applies.
#[derive(Debug, Clone, PartialEq)]
pub enum EffectCondition {
    /// Controller controls an object matching filter
    ControllerControls(ObjectFilter),

    /// Source is tapped
    SourceIsTapped,

    /// Source is untapped
    SourceIsUntapped,

    /// Source is attacking
    SourceIsAttacking,

    /// Source is blocking
    SourceIsBlocking,

    /// It's the controller's turn
    ControllersTurn,

    /// A specific player has N or more cards in graveyard
    GraveyardHasCards(PlayerId, usize),

    /// Custom condition by ID
    Custom(&'static str),
}

/// Manages all continuous effects in the game.
#[derive(Debug, Clone, Default)]
pub struct ContinuousEffectManager {
    /// All active continuous effects from resolved spells/abilities
    effects: Vec<ContinuousEffect>,

    /// Continuous effects generated from static abilities on permanents.
    /// These are regenerated periodically and don't need explicit removal.
    /// Per Rule 611.3a, these apply dynamically.
    static_ability_effects: Vec<ContinuousEffect>,

    /// Next effect ID to assign
    next_id: u64,

    /// Current timestamp (for ordering)
    current_timestamp: u64,

    // === Timestamp tracking per Rule 613.7 ===
    /// Timestamps for when objects entered their current zone.
    /// Per Rule 613.7d, objects get a timestamp when entering a zone.
    object_entry_timestamps: HashMap<ObjectId, u64>,

    /// Timestamps for when counters were last modified on objects.
    /// Per Rule 613.7c, counters of the same type share a timestamp
    /// that's updated when new counters are added.
    counter_timestamps: HashMap<ObjectId, u64>,

    /// Timestamps for when auras/equipment became attached.
    /// Per Rule 613.7e, attachments get a new timestamp when attached.
    attachment_timestamps: HashMap<ObjectId, u64>,
}

impl ContinuousEffectManager {
    /// Create a new empty manager.
    pub fn new() -> Self {
        Self::default()
    }

    /// Add a new continuous effect.
    pub fn add_effect(&mut self, mut effect: ContinuousEffect) -> ContinuousEffectId {
        let id = ContinuousEffectId::new(self.next_id);
        self.next_id += 1;

        effect.id = id;
        if effect.timestamp == 0 {
            effect.timestamp = self.next_timestamp();
        }

        self.effects.push(effect);
        id
    }

    /// Remove an effect by ID.
    pub fn remove_effect(&mut self, id: ContinuousEffectId) {
        self.effects.retain(|e| e.id != id);
    }

    /// Remove all effects from a specific source.
    pub fn remove_effects_from_source(&mut self, source: ObjectId) {
        self.effects.retain(|e| e.source != source);
    }

    /// Remove all effects with duration UntilEndOfTurn.
    pub fn cleanup_end_of_turn(&mut self) {
        self.effects
            .retain(|e| !matches!(e.duration, Until::EndOfTurn));
    }

    /// Get all effects that apply to a specific object.
    pub fn effects_for_object(&self, object_id: ObjectId) -> Vec<&ContinuousEffect> {
        self.effects
            .iter()
            .filter(|e| match &e.applies_to {
                EffectTarget::Specific(id) => *id == object_id,
                EffectTarget::Source => e.source == object_id,
                // For filter-based effects, caller needs to check the filter
                _ => true,
            })
            .collect()
    }

    /// Get registered effects sorted by layer and timestamp for application.
    ///
    /// This returns only effects registered from resolved spells/abilities.
    /// It does NOT include effects generated from static abilities on permanents
    /// (anthems, ability grants, etc.). For a complete view that includes static
    /// ability effects, use `get_all_continuous_effects()` from static_ability_processor.
    pub fn effects_sorted(&self) -> Vec<&ContinuousEffect> {
        // Only return registered effects (not static ability effects)
        let mut effects: Vec<_> = self.effects.iter().collect();

        // Sort by layer, sublayer, timestamp
        effects.sort_by(|a, b| {
            let layer_cmp = a.modification.layer().cmp(&b.modification.layer());
            if layer_cmp != std::cmp::Ordering::Equal {
                return layer_cmp;
            }

            // Within same layer, sort by sublayer for P/T
            if a.modification.layer() == Layer::PowerToughness {
                let sublayer_cmp = a
                    .modification
                    .pt_sublayer()
                    .cmp(&b.modification.pt_sublayer());
                if sublayer_cmp != std::cmp::Ordering::Equal {
                    return sublayer_cmp;
                }
            }

            // Within same layer/sublayer, sort by timestamp
            a.timestamp.cmp(&b.timestamp)
        });
        effects
    }

    /// Set the static ability effects.
    ///
    /// These are effects generated from static abilities on permanents
    /// (anthems, abilities that grant abilities, etc.). They are regenerated
    /// periodically and don't need explicit add/remove calls.
    ///
    /// Per Rule 611.3a, static ability effects apply dynamically.
    pub fn set_static_ability_effects(&mut self, effects: Vec<ContinuousEffect>) {
        self.static_ability_effects = effects;
    }

    /// Get the static ability effects (for iteration/inspection).
    pub fn static_ability_effects(&self) -> &[ContinuousEffect] {
        &self.static_ability_effects
    }

    /// Get the registered continuous effects (non-static).
    pub fn effects(&self) -> &[ContinuousEffect] {
        &self.effects
    }

    /// Get the next effect id (for deterministic state hashing).
    pub fn next_id(&self) -> u64 {
        self.next_id
    }

    /// Get the next timestamp.
    fn next_timestamp(&mut self) -> u64 {
        self.current_timestamp += 1;
        self.current_timestamp
    }

    /// Advance the timestamp (call when events occur that need ordering).
    pub fn advance_timestamp(&mut self) {
        self.current_timestamp += 1;
    }

    /// Get current timestamp.
    pub fn current_timestamp(&self) -> u64 {
        self.current_timestamp
    }

    /// Snapshot object entry timestamps in deterministic order.
    pub fn object_entry_timestamps_snapshot(&self) -> Vec<(ObjectId, u64)> {
        let mut entries: Vec<(ObjectId, u64)> = self
            .object_entry_timestamps
            .iter()
            .map(|(id, ts)| (*id, *ts))
            .collect();
        entries.sort_by_key(|(id, _)| *id);
        entries
    }

    /// Snapshot counter timestamps in deterministic order.
    pub fn counter_timestamps_snapshot(&self) -> Vec<(ObjectId, u64)> {
        let mut entries: Vec<(ObjectId, u64)> = self
            .counter_timestamps
            .iter()
            .map(|(id, ts)| (*id, *ts))
            .collect();
        entries.sort_by_key(|(id, _)| *id);
        entries
    }

    /// Snapshot attachment timestamps in deterministic order.
    pub fn attachment_timestamps_snapshot(&self) -> Vec<(ObjectId, u64)> {
        let mut entries: Vec<(ObjectId, u64)> = self
            .attachment_timestamps
            .iter()
            .map(|(id, ts)| (*id, *ts))
            .collect();
        entries.sort_by_key(|(id, _)| *id);
        entries
    }

    // === Timestamp tracking methods per Rule 613.7 ===

    /// Record when an object enters a zone.
    /// Per Rule 613.7d, the object gets a timestamp at this moment.
    pub fn record_entry(&mut self, object_id: ObjectId) {
        let ts = self.next_timestamp();
        self.object_entry_timestamps.insert(object_id, ts);
    }

    /// Record when counters are added to an object.
    /// Per Rule 613.7c, counters share a timestamp that's updated when new counters are added.
    pub fn record_counter_change(&mut self, object_id: ObjectId) {
        let ts = self.next_timestamp();
        self.counter_timestamps.insert(object_id, ts);
    }

    /// Record when an aura/equipment becomes attached.
    /// Per Rule 613.7e, attachments get a new timestamp when attached.
    pub fn record_attachment(&mut self, attachment_id: ObjectId) {
        let ts = self.next_timestamp();
        self.attachment_timestamps.insert(attachment_id, ts);
    }

    /// Get the timestamp for when an object entered its current zone.
    pub fn get_entry_timestamp(&self, object_id: ObjectId) -> Option<u64> {
        self.object_entry_timestamps.get(&object_id).copied()
    }

    /// Get the timestamp for an object's counters.
    /// If no specific counter timestamp exists, returns the entry timestamp.
    pub fn get_counter_timestamp(&self, object_id: ObjectId) -> Option<u64> {
        self.counter_timestamps
            .get(&object_id)
            .copied()
            .or_else(|| self.object_entry_timestamps.get(&object_id).copied())
    }

    /// Get the timestamp for when an attachment became attached.
    pub fn get_attachment_timestamp(&self, attachment_id: ObjectId) -> Option<u64> {
        self.attachment_timestamps.get(&attachment_id).copied()
    }

    /// Remove timestamp tracking for an object (when it leaves the zone).
    pub fn remove_timestamps(&mut self, object_id: ObjectId) {
        self.object_entry_timestamps.remove(&object_id);
        self.counter_timestamps.remove(&object_id);
        self.attachment_timestamps.remove(&object_id);
    }
}

// === Builder functions for common continuous effects ===

impl ContinuousEffect {
    /// Create a new continuous effect.
    /// Defaults to `StaticAbility` source type.
    pub fn new(
        source: ObjectId,
        controller: PlayerId,
        applies_to: EffectTarget,
        modification: Modification,
    ) -> Self {
        Self {
            id: ContinuousEffectId(0), // Will be set when added to manager
            source,
            controller,
            applies_to,
            modification,
            timestamp: 0, // Will be set when added to manager
            duration: Until::Forever,
            condition: None,
            source_type: EffectSourceType::default(),
        }
    }

    /// Set the duration.
    pub fn until(mut self, duration: Until) -> Self {
        self.duration = duration;
        self
    }

    /// Set a condition.
    pub fn with_condition(mut self, condition: EffectCondition) -> Self {
        self.condition = Some(condition);
        self
    }

    /// Set the source type.
    pub fn with_source_type(mut self, source_type: EffectSourceType) -> Self {
        self.source_type = source_type;
        self
    }

    /// Create a resolution effect that locks targets (from a resolving spell/ability).
    /// Per Rule 611.2c, these effects only apply to the specific targets chosen at resolution.
    pub fn from_resolution(
        source: ObjectId,
        controller: PlayerId,
        locked_targets: Vec<ObjectId>,
        modification: Modification,
    ) -> Self {
        Self::new(
            source,
            controller,
            EffectTarget::AllPermanents, // Will be filtered by locked_targets
            modification,
        )
        .with_source_type(EffectSourceType::Resolution { locked_targets })
    }

    /// Create a +N/+M effect from a resolving spell/ability.
    /// Per Rule 611.2c, this only applies to the target chosen at resolution.
    pub fn pump(
        source: ObjectId,
        controller: PlayerId,
        target: ObjectId,
        power: i32,
        toughness: i32,
        duration: Until,
    ) -> Self {
        Self::from_resolution(
            source,
            controller,
            vec![target],
            Modification::ModifyPowerToughness { power, toughness },
        )
        .until(duration)
    }

    /// Create an anthem effect (+N/+M to filtered creatures).
    pub fn anthem(
        source: ObjectId,
        controller: PlayerId,
        filter: ObjectFilter,
        power: i32,
        toughness: i32,
    ) -> Self {
        Self::new(
            source,
            controller,
            EffectTarget::Filter(filter),
            Modification::ModifyPowerToughness { power, toughness },
        )
    }

    /// Create a "gains ability" effect.
    pub fn grant_ability(
        source: ObjectId,
        controller: PlayerId,
        target: ObjectId,
        ability: StaticAbility,
        duration: Until,
    ) -> Self {
        Self::new(
            source,
            controller,
            EffectTarget::Specific(target),
            Modification::AddAbility(ability),
        )
        .until(duration)
    }

    /// Create a control-changing effect.
    pub fn gain_control(
        source: ObjectId,
        controller: PlayerId,
        target: ObjectId,
        new_controller: PlayerId,
    ) -> Self {
        Self::new(
            source,
            controller,
            EffectTarget::Specific(target),
            Modification::ChangeController(new_controller),
        )
    }
}

// =============================================================================
// Characteristic Calculation
// =============================================================================
//
// These functions calculate an object's characteristics after applying all
// continuous effects in the correct layer order.

/// Calculated characteristics for an object after applying continuous effects.
#[derive(Debug, Clone)]
pub struct CalculatedCharacteristics {
    pub power: Option<i32>,
    pub toughness: Option<i32>,
    pub card_types: Vec<CardType>,
    pub subtypes: Vec<Subtype>,
    pub supertypes: Vec<Supertype>,
    pub colors: ColorSet,
    pub abilities: Vec<Ability>,
    /// Static abilities that this object currently has (including from effects)
    pub static_abilities: Vec<StaticAbility>,
    pub controller: PlayerId,
}

/// Context needed for calculating characteristics.
pub struct CalculationContext<'a> {
    pub objects: &'a HashMap<ObjectId, Object>,
    pub effects: &'a ContinuousEffectManager,
    pub battlefield: &'a [ObjectId],
    pub game: &'a crate::game_state::GameState,
}

impl ContinuousEffectManager {
    /// Calculate characteristics for an object, applying all continuous effects.
    pub fn calculate_characteristics(
        &self,
        object_id: ObjectId,
        objects: &HashMap<ObjectId, Object>,
        battlefield: &[ObjectId],
        game: &crate::game_state::GameState,
    ) -> Option<CalculatedCharacteristics> {
        let object = objects.get(&object_id)?;

        let ctx = CalculationContext {
            objects,
            effects: self,
            battlefield,
            game,
        };

        Some(calculate_with_layers(object, &ctx))
    }
}

/// Calculate characteristics for an object using a provided list of effects.
///
/// This function is used when effects need to include dynamically generated
/// effects (e.g., from static abilities) in addition to registered effects.
pub fn calculate_characteristics_with_effects(
    object_id: ObjectId,
    objects: &HashMap<ObjectId, Object>,
    effects: &[ContinuousEffect],
    battlefield: &[ObjectId],
    commanders: &HashSet<ObjectId>,
    game: &crate::game_state::GameState,
) -> Option<CalculatedCharacteristics> {
    let object = objects.get(&object_id)?;

    Some(calculate_with_layers_direct_internal(
        object,
        objects,
        effects,
        battlefield,
        commanders,
        game,
        DependencySortMode::Baseline,
    ))
}

pub(crate) fn calculate_characteristics_with_effects_simple(
    object_id: ObjectId,
    objects: &HashMap<ObjectId, Object>,
    effects: &[ContinuousEffect],
    battlefield: &[ObjectId],
    commanders: &HashSet<ObjectId>,
    game: &crate::game_state::GameState,
) -> Option<CalculatedCharacteristics> {
    let object = objects.get(&object_id)?;

    Some(calculate_with_layers_direct_internal(
        object,
        objects,
        effects,
        battlefield,
        commanders,
        game,
        DependencySortMode::Heuristic,
    ))
}

/// Apply all layers to calculate final characteristics using provided effects.
fn calculate_with_layers_direct_internal(
    object: &Object,
    objects: &HashMap<ObjectId, Object>,
    effects: &[ContinuousEffect],
    battlefield: &[ObjectId],
    commanders: &HashSet<ObjectId>,
    game: &crate::game_state::GameState,
    sort_mode: DependencySortMode,
) -> CalculatedCharacteristics {
    use crate::dependency::sort_layer_effects;
    use crate::dependency::sort_layer_effects_with_baseline;

    // Start with base characteristics
    let mut chars = CalculatedCharacteristics {
        power: object.base_power.as_ref().map(|p| p.base_value()),
        toughness: object.base_toughness.as_ref().map(|t| t.base_value()),
        card_types: object.card_types.clone(),
        subtypes: object.subtypes.clone(),
        supertypes: object.supertypes.clone(),
        colors: object.colors(),
        abilities: object.abilities.clone(),
        static_abilities: extract_static_abilities(&object.abilities),
        controller: object.controller,
    };

    // Add abilities from ability-granting counters (deathtouch counter, flying counter, etc.)
    add_abilities_from_counters(object, &mut chars);

    // Group effects by layer for dependency-aware sorting within each layer
    let mut effects_by_layer: HashMap<Layer, Vec<&ContinuousEffect>> = HashMap::new();
    for effect in effects {
        effects_by_layer
            .entry(effect.modification.layer())
            .or_default()
            .push(effect);
    }

    // Process layers in order (1-6)
    let layers_1_to_6 = [
        Layer::Copy,
        Layer::Control,
        Layer::Text,
        Layer::Type,
        Layer::Color,
        Layer::Ability,
    ];

    // Track which abilities have been removed (for dependency detection)
    let mut abilities_removed = false;

    for layer in layers_1_to_6 {
        let layer_effects = match effects_by_layer.get(&layer) {
            Some(effects) => effects.clone(),
            None => continue,
        };

        // Apply dependency-aware sorting within this layer
        let sorted_effects = match sort_mode {
            DependencySortMode::Heuristic => sort_layer_effects(&layer_effects),
            DependencySortMode::Baseline => {
                let baseline = build_layer_baseline(
                    objects,
                    effects,
                    battlefield,
                    commanders,
                    game,
                    layer,
                    None,
                );
                sort_layer_effects_with_baseline(&layer_effects, &baseline, objects, game)
            }
        };

        // Apply effects in dependency order
        for effect in sorted_effects {
            if !effect_applies_to_direct(effect, object, &chars, objects, battlefield, commanders) {
                continue;
            }

            apply_modification_to_chars(
                &effect.modification,
                &mut chars,
                objects,
                &mut abilities_removed,
                effect.controller,
                object,
                battlefield,
                game,
            );
        }
    }

    // Layer 7: Power/Toughness with proper sublayer handling
    // Process in sublayer order: 7a, 7b, 7c, 7d

    // First, check for level abilities (if not removed) - these apply in 7b (Setting)
    // Level P/T needs to be applied before other 7b effects so it can be overridden
    if !abilities_removed {
        if let Some((lp, lt)) = get_level_ability_pt(object) {
            chars.power = Some(lp);
            chars.toughness = Some(lt);
        }
        // Add level-granted abilities to the characteristics
        let level_abilities = get_level_granted_abilities(object);
        for ability in level_abilities {
            // Add to abilities and static abilities - both use new type now
            chars
                .abilities
                .push(Ability::static_ability(ability.clone()));
            chars.static_abilities.push(ability);
        }
    }

    // Now process Layer 7 effects from continuous effects
    if let Some(pt_effects) = effects_by_layer.get(&Layer::PowerToughness) {
        // Apply dependency-aware sorting within Layer 7 sublayers.
        let sorted_pt = match sort_mode {
            DependencySortMode::Heuristic => sort_layer_effects(pt_effects),
            DependencySortMode::Baseline => {
                let baseline = build_layer_baseline(
                    objects,
                    effects,
                    battlefield,
                    commanders,
                    game,
                    Layer::PowerToughness,
                    None,
                );
                sort_layer_effects_with_baseline(pt_effects, &baseline, objects, game)
            }
        };

        for effect in sorted_pt {
            if !effect_applies_to_direct(effect, object, &chars, objects, battlefield, commanders) {
                continue;
            }

            apply_modification_to_chars(
                &effect.modification,
                &mut chars,
                objects,
                &mut abilities_removed,
                effect.controller,
                object,
                battlefield,
                game,
            );
        }
    }

    // Apply counter modifications for Layer 7c (after other 7c effects by timestamp)
    apply_counter_modifications(object, &mut chars.power, &mut chars.toughness);

    chars
}

/// Check if an effect applies to a specific object (direct version without CalculationContext).
fn effect_applies_to_direct(
    effect: &ContinuousEffect,
    object: &Object,
    chars: &CalculatedCharacteristics,
    objects: &HashMap<ObjectId, Object>,
    battlefield: &[ObjectId],
    commanders: &HashSet<ObjectId>,
) -> bool {
    // First, check if this is a Resolution effect with locked targets.
    if let EffectSourceType::Resolution { ref locked_targets } = effect.source_type {
        if !locked_targets.contains(&object.id) {
            return false;
        }
        return object.zone == Zone::Battlefield;
    }

    // For StaticAbility, CharacteristicDefining, Combat, and Copy effects,
    // check the EffectTarget as normal (they apply dynamically).
    match &effect.applies_to {
        EffectTarget::Specific(id) => *id == object.id,
        EffectTarget::Source => effect.source == object.id,
        EffectTarget::AllPermanents => object.zone == Zone::Battlefield,
        EffectTarget::AllCreatures => {
            object.zone == Zone::Battlefield && chars.card_types.contains(&CardType::Creature)
        }
        EffectTarget::Filter(filter) => filter_matches_direct(
            filter,
            object,
            chars,
            effect.controller,
            objects,
            battlefield,
            commanders,
        ),
        EffectTarget::AttachedTo(source_id) => {
            // The effect applies to whatever permanent the source is attached to
            if let Some(source) = objects.get(source_id) {
                source.attached_to == Some(object.id) && object.zone == Zone::Battlefield
            } else {
                false
            }
        }
    }
}

/// Check if an object matches a filter (direct version without CalculationContext).
fn filter_matches_direct(
    filter: &ObjectFilter,
    object: &Object,
    chars: &CalculatedCharacteristics,
    effect_controller: PlayerId,
    _objects: &HashMap<ObjectId, Object>,
    _battlefield: &[ObjectId],
    commanders: &HashSet<ObjectId>,
) -> bool {
    // Check zone
    if let Some(zone) = filter.zone
        && object.zone != zone
    {
        return false;
    }

    // Check card types (using calculated types)
    if !filter.card_types.is_empty()
        && !filter
            .card_types
            .iter()
            .any(|t| chars.card_types.contains(t))
    {
        return false;
    }

    // Check subtypes (using calculated subtypes)
    if !filter.subtypes.is_empty() && !filter.subtypes.iter().any(|t| chars.subtypes.contains(t)) {
        return false;
    }
    if filter
        .excluded_subtypes
        .iter()
        .any(|t| chars.subtypes.contains(t))
    {
        return false;
    }

    // Check controller
    if let Some(ref controller_filter) = filter.controller {
        use crate::filter::PlayerFilter;
        match controller_filter {
            PlayerFilter::You => {
                // "You" means the controller of the effect's source
                if chars.controller != effect_controller {
                    return false;
                }
            }
            PlayerFilter::Opponent => {
                // Opponent of the effect's controller
                if chars.controller == effect_controller {
                    return false;
                }
            }
            PlayerFilter::Specific(player_id) => {
                if chars.controller != *player_id {
                    return false;
                }
            }
            PlayerFilter::Any => {}
            // Other variants not applicable in this context
            _ => {}
        }
    }

    // Check colors (using calculated colors)
    if let Some(colors) = filter.colors
        && chars.colors.intersection(colors).is_empty()
    {
        return false;
    }

    // Check excluded supertypes (e.g., nonbasic lands for Blood Moon)
    if filter
        .excluded_supertypes
        .iter()
        .any(|t| chars.supertypes.contains(t))
    {
        return false;
    }

    // Check if must be a commander
    if filter.is_commander && !commanders.contains(&object.id) {
        return false;
    }

    true
}

/// Apply a modification to calculated characteristics.
fn apply_modification_to_chars(
    modification: &Modification,
    chars: &mut CalculatedCharacteristics,
    objects: &HashMap<ObjectId, Object>,
    abilities_removed: &mut bool,
    effect_controller: PlayerId,
    object: &Object,
    battlefield: &[ObjectId],
    game: &crate::game_state::GameState,
) {
    match modification {
        // Layer 1: Copy
        Modification::CopyOf(target_id) => {
            if let Some(target) = objects.get(target_id) {
                chars.power = target.base_power.as_ref().map(|p| p.base_value());
                chars.toughness = target.base_toughness.as_ref().map(|t| t.base_value());
                chars.card_types = target.card_types.clone();
                chars.subtypes = target.subtypes.clone();
                chars.supertypes = target.supertypes.clone();
                chars.colors = target.colors();
                chars.abilities = target.abilities.clone();
                chars.static_abilities = extract_static_abilities(&target.abilities);
            }
        }

        // Layer 2: Control
        Modification::ChangeController(new_controller) => {
            chars.controller = *new_controller;
        }

        // Layer 4: Type changes
        Modification::AddCardTypes(types) => {
            for t in types {
                if !chars.card_types.contains(t) {
                    chars.card_types.push(*t);
                }
            }
        }
        Modification::RemoveCardTypes(types) => {
            chars.card_types.retain(|t| !types.contains(t));
        }
        Modification::SetCardTypes(types) => {
            chars.card_types = types.clone();
        }
        Modification::AddSubtypes(subtypes) => {
            for st in subtypes {
                if !chars.subtypes.contains(st) {
                    chars.subtypes.push(*st);
                }
            }
        }
        Modification::RemoveSubtypes(subtypes) => {
            chars.subtypes.retain(|st| !subtypes.contains(st));
        }
        Modification::SetSubtypes(subtypes) => {
            // SetSubtypes replaces land subtypes only, keeping non-land subtypes like Saga
            let non_land_subtypes: Vec<_> = chars
                .subtypes
                .iter()
                .filter(|st| !st.is_land_subtype())
                .cloned()
                .collect();
            chars.subtypes = non_land_subtypes;
            chars.subtypes.extend(subtypes.iter().cloned());
        }
        Modification::AddSupertypes(supertypes) => {
            for st in supertypes {
                if !chars.supertypes.contains(st) {
                    chars.supertypes.push(*st);
                }
            }
        }

        // Layer 5: Color changes
        Modification::AddColors(colors) => {
            chars.colors = chars.colors.union(*colors);
        }
        Modification::RemoveColors(colors) => {
            // Remove colors using bitwise AND with NOT
            let current = chars.colors;
            chars.colors = ColorSet::new();
            for color in Color::ALL {
                if current.contains(color) && !colors.contains(color) {
                    chars.colors = chars.colors.with(color);
                }
            }
        }
        Modification::SetColors(colors) => {
            chars.colors = *colors;
        }

        // Layer 6: Ability changes
        Modification::AddAbility(ability) => {
            // Create ability with the new type
            let new_ability = Ability::static_ability(ability.clone());
            chars.abilities.push(new_ability);
            chars.static_abilities.push(ability.clone());
        }
        Modification::AddAbilityGeneric(ability) => {
            if let AbilityKind::Static(ref sa) = ability.kind {
                chars.static_abilities.push(sa.clone());
            }
            chars.abilities.push(ability.clone());
        }
        Modification::CopyActivatedAbilities {
            filter,
            counter,
            include_mana,
            exclude_source_name,
            exclude_source_id,
        } => {
            use crate::ability::AbilityKind;
            use crate::static_ability_processor::get_all_continuous_effects;

            let effects = get_all_continuous_effects(game);
            let commanders = &game.commanders;
            let battlefield = &game.battlefield;

            for candidate in objects.values() {
                if *exclude_source_id && candidate.id == object.id {
                    continue;
                }
                if *exclude_source_name && candidate.name == object.name {
                    continue;
                }
                if let Some(counter_type) = counter
                    && candidate.counters.get(counter_type).copied().unwrap_or(0) == 0
                {
                    continue;
                }

                let Some(candidate_chars) = calculate_characteristics_with_effects_simple(
                    candidate.id,
                    objects,
                    &effects,
                    battlefield,
                    commanders,
                    game,
                ) else {
                    continue;
                };

                if !filter_matches_with_controller(
                    filter,
                    candidate,
                    &candidate_chars,
                    game,
                    effect_controller,
                ) {
                    continue;
                }

                for ability in &candidate_chars.abilities {
                    let is_activated = matches!(ability.kind, AbilityKind::Activated(_));
                    let is_mana = matches!(ability.kind, AbilityKind::Mana(_));
                    if !is_activated && !(*include_mana && is_mana) {
                        continue;
                    }
                    chars.abilities.push(ability.clone());
                }
            }
        }
        Modification::AddCombatDamageDrawAbility => {
            chars.abilities.push(Ability::triggered(
                crate::triggers::Trigger::this_deals_combat_damage_to_player(),
                vec![crate::effect::Effect::draw(1)],
            ));
        }
        Modification::RemoveAbility(ability) => {
            // Compare abilities directly using new type
            chars.abilities.retain(|a| {
                if let AbilityKind::Static(ref sa) = a.kind {
                    sa != ability
                } else {
                    true
                }
            });
            chars.static_abilities.retain(|sa| sa != ability);
        }
        Modification::RemoveAllAbilities => {
            chars.abilities.clear();
            chars.static_abilities.clear();
            *abilities_removed = true;
        }

        // Layer 7a: Characteristic-defining P/T
        Modification::SetPower { value, sublayer }
            if *sublayer == PtSublayer::CharacteristicDefining =>
        {
            chars.power = Some(resolve_value_direct(
                value,
                objects,
                battlefield,
                object.id,
                effect_controller,
                game,
            ));
        }
        Modification::SetToughness { value, sublayer }
            if *sublayer == PtSublayer::CharacteristicDefining =>
        {
            chars.toughness = Some(resolve_value_direct(
                value,
                objects,
                battlefield,
                object.id,
                effect_controller,
                game,
            ));
        }
        Modification::SetPowerToughness {
            power,
            toughness,
            sublayer,
        } if *sublayer == PtSublayer::CharacteristicDefining => {
            chars.power = Some(resolve_value_direct(
                power,
                objects,
                battlefield,
                object.id,
                effect_controller,
                game,
            ));
            chars.toughness = Some(resolve_value_direct(
                toughness,
                objects,
                battlefield,
                object.id,
                effect_controller,
                game,
            ));
        }

        // Layer 7b: Setting P/T
        Modification::SetPower { value, sublayer } if *sublayer == PtSublayer::Setting => {
            chars.power = Some(resolve_value_direct(
                value,
                objects,
                battlefield,
                object.id,
                effect_controller,
                game,
            ));
        }
        Modification::SetToughness { value, sublayer } if *sublayer == PtSublayer::Setting => {
            chars.toughness = Some(resolve_value_direct(
                value,
                objects,
                battlefield,
                object.id,
                effect_controller,
                game,
            ));
        }
        Modification::SetPowerToughness {
            power,
            toughness,
            sublayer,
        } if *sublayer == PtSublayer::Setting => {
            chars.power = Some(resolve_value_direct(
                power,
                objects,
                battlefield,
                object.id,
                effect_controller,
                game,
            ));
            chars.toughness = Some(resolve_value_direct(
                toughness,
                objects,
                battlefield,
                object.id,
                effect_controller,
                game,
            ));
        }

        // Layer 7c: Modifying P/T
        Modification::ModifyPower(delta) => {
            if let Some(ref mut p) = chars.power {
                *p += delta;
            }
        }
        Modification::ModifyToughness(delta) => {
            if let Some(ref mut t) = chars.toughness {
                *t += delta;
            }
        }
        Modification::ModifyPowerToughness {
            power: p_delta,
            toughness: t_delta,
        } => {
            if let Some(ref mut p) = chars.power {
                *p += p_delta;
            }
            if let Some(ref mut t) = chars.toughness {
                *t += t_delta;
            }
        }

        // Layer 7e: Switching P/T
        Modification::SwitchPowerToughness => {
            std::mem::swap(&mut chars.power, &mut chars.toughness);
        }

        // Catch any unhandled SetPower/SetToughness/SetPowerToughness with other sublayers
        Modification::SetPower { .. }
        | Modification::SetToughness { .. }
        | Modification::SetPowerToughness { .. } => {
            // These should have been handled by the sublayer-specific cases above
        }

        // Other modifications that don't affect characteristics calculation
        Modification::ChangeText { .. } => {
            // Text changes are handled separately
        }
        Modification::RemoveSupertypes(supertypes) => {
            chars.supertypes.retain(|st| !supertypes.contains(st));
        }
        Modification::RemoveAllCreatureTypes => {
            chars.subtypes.retain(|st| !st.is_creature_type());
        }
        Modification::MakeColorless => {
            chars.colors = ColorSet::new();
        }
        Modification::CantBeBlocked
        | Modification::CantAttack
        | Modification::CantBlock
        | Modification::DoesntUntap => {
            // Combat/untap restrictions, not characteristic changes
        }
    }
}

/// Resolve a Value to an i32 (direct version without CalculationContext).
fn resolve_value_direct(
    value: &Value,
    objects: &HashMap<ObjectId, Object>,
    battlefield: &[ObjectId],
    source: ObjectId,
    controller: PlayerId,
    game: &crate::game_state::GameState,
) -> i32 {
    use crate::target::FilterContext;

    match value {
        Value::Fixed(n) => *n,

        Value::X => 0, // X is 0 unless specified

        Value::Count(filter) => {
            let filter_ctx = FilterContext {
                you: Some(controller),
                source: Some(source),
                active_player: None,
                opponents: Vec::new(),
                teammates: Vec::new(),
                defending_player: None,
                attacking_player: None,
                your_commanders: Vec::new(),
                iterated_player: None,
                target_players: Vec::new(),
                tagged_objects: HashMap::new(),
            };

            battlefield
                .iter()
                .filter_map(|&id| objects.get(&id))
                .filter(|obj| filter.matches(obj, &filter_ctx, game))
                .count() as i32
        }

        Value::SourcePower => objects
            .get(&source)
            .and_then(|o| o.base_power.as_ref())
            .map(|p| p.base_value())
            .unwrap_or(0),

        Value::SourceToughness => objects
            .get(&source)
            .and_then(|o| o.base_toughness.as_ref())
            .map(|t| t.base_value())
            .unwrap_or(0),

        Value::PowerOf(_target_spec) => {
            // PowerOf requires target resolution which isn't available here
            // In the layer system, these values should have been resolved during spell resolution
            0
        }

        Value::ToughnessOf(_target_spec) => {
            // ToughnessOf requires target resolution which isn't available here
            0
        }

        _ => 0, // Other Value variants default to 0
    }
}

/// Apply all layers to calculate final characteristics.
fn calculate_with_layers(object: &Object, ctx: &CalculationContext) -> CalculatedCharacteristics {
    use crate::dependency::sort_layer_effects_with_baseline;

    // Start with base characteristics
    let mut chars = CalculatedCharacteristics {
        power: object.base_power.as_ref().map(|p| p.base_value()),
        toughness: object.base_toughness.as_ref().map(|t| t.base_value()),
        card_types: object.card_types.clone(),
        subtypes: object.subtypes.clone(),
        supertypes: object.supertypes.clone(),
        colors: object.colors(),
        abilities: object.abilities.clone(),
        static_abilities: extract_static_abilities(&object.abilities),
        controller: object.controller,
    };

    // Add abilities from ability-granting counters (deathtouch counter, flying counter, etc.)
    add_abilities_from_counters(object, &mut chars);

    // Get all effects sorted by layer/sublayer/timestamp
    let effects = ctx.effects.effects_sorted();
    let all_effects: Vec<ContinuousEffect> = effects.iter().map(|e| (*e).clone()).collect();

    // Group effects by layer for dependency-aware sorting within each layer
    let mut effects_by_layer: HashMap<Layer, Vec<&ContinuousEffect>> = HashMap::new();
    for effect in &effects {
        effects_by_layer
            .entry(effect.modification.layer())
            .or_default()
            .push(*effect);
    }

    // Process layers in order (1-7)
    let layers = [
        Layer::Copy,
        Layer::Control,
        Layer::Text,
        Layer::Type,
        Layer::Color,
        Layer::Ability,
        Layer::PowerToughness,
    ];

    // Track which abilities have been removed (for dependency detection)
    let mut abilities_removed = false;

    for layer in layers {
        let layer_effects = match effects_by_layer.get(&layer) {
            Some(effects) => effects.clone(),
            None => continue,
        };

        // Apply dependency-aware sorting within this layer
        // This handles Rule 613.8 - effects that depend on each other
        let sorted_effects = {
            let baseline = build_layer_baseline(
                ctx.objects,
                &all_effects,
                ctx.battlefield,
                &ctx.game.commanders,
                ctx.game,
                layer,
                None,
            );
            sort_layer_effects_with_baseline(&layer_effects, &baseline, ctx.objects, ctx.game)
        };

        // Apply effects in dependency order
        for effect in sorted_effects {
            // Check if this effect applies to our object
            if !effect_applies_to(effect, object, &chars, ctx) {
                continue;
            }

            // Apply the modification
            match &effect.modification {
                // Layer 1: Copy
                Modification::CopyOf(target_id) => {
                    // Per MTG rule 707.2, copying copies the copiable values:
                    // name, mana cost, color indicator, card type, subtype, supertype,
                    // rules text, power, toughness, and loyalty.
                    // It does NOT copy counters, damage, or other non-copiable state.
                    if let Some(target) = ctx.objects.get(target_id) {
                        // Copy base characteristics from the target
                        chars.power = target.base_power.as_ref().map(|p| p.base_value());
                        chars.toughness = target.base_toughness.as_ref().map(|t| t.base_value());
                        chars.card_types = target.card_types.clone();
                        chars.subtypes = target.subtypes.clone();
                        chars.supertypes = target.supertypes.clone();
                        chars.colors = target.colors();
                        chars.abilities = target.abilities.clone();
                        chars.static_abilities = extract_static_abilities(&target.abilities);
                        // Note: controller is NOT copied - that's determined by who cast the Clone
                    }
                }

                // Layer 2: Control
                Modification::ChangeController(new_controller) => {
                    chars.controller = *new_controller;
                }

                // Layer 4: Type changes
                Modification::AddCardTypes(types) => {
                    for t in types {
                        if !chars.card_types.contains(t) {
                            chars.card_types.push(*t);
                        }
                    }
                }
                Modification::RemoveCardTypes(types) => {
                    chars.card_types.retain(|t| !types.contains(t));
                }
                Modification::SetCardTypes(types) => {
                    chars.card_types = types.clone();
                }
                Modification::AddSubtypes(types) => {
                    for t in types {
                        if !chars.subtypes.contains(t) {
                            chars.subtypes.push(*t);
                        }
                    }
                }
                Modification::RemoveSubtypes(types) => {
                    chars.subtypes.retain(|t| !types.contains(t));
                }
                Modification::SetSubtypes(types) => {
                    // Blood Moon: Only replace LAND subtypes, keep non-land subtypes
                    // Per MTG rules, type-changing effects that set land types only affect
                    // land subtypes (Plains, Island, Swamp, Mountain, Forest, Urza's, etc.)
                    // Non-land subtypes (Saga, Aura, creature types) are preserved.

                    // Keep non-land subtypes
                    let mut new_subtypes: Vec<Subtype> = chars
                        .subtypes
                        .iter()
                        .filter(|st| !st.is_land_subtype())
                        .cloned()
                        .collect();

                    // Add the new subtypes (typically just Mountain for Blood Moon)
                    for subtype in types {
                        if !new_subtypes.contains(subtype) {
                            new_subtypes.push(*subtype);
                        }
                    }

                    chars.subtypes = new_subtypes;
                }
                Modification::AddSupertypes(types) => {
                    for t in types {
                        if !chars.supertypes.contains(t) {
                            chars.supertypes.push(*t);
                        }
                    }
                }
                Modification::RemoveSupertypes(types) => {
                    chars.supertypes.retain(|t| !types.contains(t));
                }
                Modification::RemoveAllCreatureTypes => {
                    chars.subtypes.retain(|t| !t.is_creature_type());
                }

                // Layer 5: Color changes
                Modification::AddColors(colors) => {
                    chars.colors = chars.colors.union(*colors);
                }
                Modification::RemoveColors(colors) => {
                    // Remove each color in the set
                    use crate::color::Color;
                    for color in [
                        Color::White,
                        Color::Blue,
                        Color::Black,
                        Color::Red,
                        Color::Green,
                    ] {
                        if colors.contains(color) {
                            chars.colors = chars.colors.without(color);
                        }
                    }
                }
                Modification::SetColors(colors) => {
                    chars.colors = *colors;
                }
                Modification::MakeColorless => {
                    chars.colors = ColorSet::COLORLESS;
                }

                // Layer 6: Ability changes
                Modification::AddAbility(ability) => {
                    if !chars.static_abilities.contains(ability) {
                        chars.static_abilities.push(ability.clone());
                    }
                }
                Modification::AddCombatDamageDrawAbility => {
                    chars.abilities.push(Ability::triggered(
                        crate::triggers::Trigger::this_deals_combat_damage_to_player(),
                        vec![crate::effect::Effect::draw(1)],
                    ));
                }
                Modification::RemoveAbility(ability) => {
                    chars.static_abilities.retain(|a| a != ability);
                }
                Modification::RemoveAllAbilities => {
                    chars.abilities.clear();
                    chars.static_abilities.clear();
                    abilities_removed = true;
                }
                Modification::CantBeBlocked => {
                    chars.static_abilities.push(StaticAbility::unblockable());
                }
                Modification::CantAttack => {
                    chars.static_abilities.push(StaticAbility::defender());
                }
                Modification::CantBlock => {
                    chars.static_abilities.push(StaticAbility::cant_block());
                }
                Modification::DoesntUntap => {
                    chars.static_abilities.push(StaticAbility::doesnt_untap());
                }

                // Layer 7: P/T changes are handled separately below
                _ => {}
            }
        }
    }

    // Now handle Layer 7 (P/T) with proper sublayer ordering
    // We need to collect P/T effects and apply them in sublayer order

    // Check for LevelAbilities if abilities weren't removed
    let level_pt = if !abilities_removed {
        get_level_ability_pt(object)
    } else {
        None
    };

    // If level abilities set P/T, use that as the "base" for layer 7b
    if let Some((lp, lt)) = level_pt {
        chars.power = Some(lp);
        chars.toughness = Some(lt);
    }

    // Apply Layer 7 effects in sublayer order
    apply_layer_7_effects(object, ctx, &mut chars, abilities_removed);

    // Add abilities from level tiers if not removed
    if !abilities_removed {
        let level_abilities = get_level_granted_abilities(object);
        for ability in level_abilities {
            if !chars.static_abilities.contains(&ability) {
                chars.static_abilities.push(ability);
            }
        }
    }

    chars
}

/// Apply Layer 7 effects (P/T modifications) in sublayer order.
///
/// Per Rule 613.4, the sublayers are:
/// - 7a: CDAs that define P/T
/// - 7b: Effects that set P/T to specific values
/// - 7c: Effects that modify P/T (including +1/+1 and -1/-1 counters)
/// - 7d: Effects that switch P/T
///
/// IMPORTANT: Per Rule 613.4c, counters are part of sublayer 7c, not a separate sublayer.
/// All 7c effects (including counters) are applied in timestamp order together.
fn apply_layer_7_effects(
    object: &Object,
    ctx: &CalculationContext,
    chars: &mut CalculatedCharacteristics,
    _abilities_removed: bool,
) {
    use crate::dependency::sort_layer_effects_with_baseline;

    let effects = ctx.effects.effects_sorted();
    let all_effects: Vec<ContinuousEffect> = effects.iter().map(|e| (*e).clone()).collect();

    // Track P/T through sublayers
    let mut power = chars.power;
    let mut toughness = chars.toughness;

    // Collect all Layer 7 effects that apply to this object
    let pt_effects: Vec<&ContinuousEffect> = effects
        .into_iter()
        .filter(|e| e.modification.layer() == Layer::PowerToughness)
        .filter(|e| effect_applies_to(e, object, chars, ctx))
        .collect();

    // Sort by sublayer with dependency handling inside each sublayer.
    let pt_effects = {
        let baseline = build_layer_baseline(
            ctx.objects,
            &all_effects,
            ctx.battlefield,
            &ctx.game.commanders,
            ctx.game,
            Layer::PowerToughness,
            None,
        );
        sort_layer_effects_with_baseline(&pt_effects, &baseline, ctx.objects, ctx.game)
    };

    // Get counter timestamp for proper 7c ordering
    // Counters get a timestamp when the object enters the battlefield or when new counters are added
    let counter_timestamp = ctx.effects.get_counter_timestamp(object.id);

    // Track whether we've applied counter modifications (for 7c ordering)
    let mut counters_applied = false;

    // Apply in order, interleaving counters at the right point in 7c
    for effect in &pt_effects {
        let effect_sublayer = effect.modification.pt_sublayer();

        // If we're in sublayer 7c (Modifying) and counters haven't been applied yet,
        // check if we should apply them now based on timestamp
        if effect_sublayer == Some(PtSublayer::Modifying) && !counters_applied {
            // Apply counters before this effect if their timestamp is earlier
            if counter_timestamp.is_none_or(|ct| ct <= effect.timestamp) {
                apply_counter_modifications(object, &mut power, &mut toughness);
                counters_applied = true;
            }
        }

        // If we're past sublayer 7c (now in 7d Switching) and counters weren't applied,
        // apply them now (at the end of 7c)
        if effect_sublayer == Some(PtSublayer::Switching) && !counters_applied {
            apply_counter_modifications(object, &mut power, &mut toughness);
            counters_applied = true;
        }

        match &effect.modification {
            Modification::SetPower { value, .. } => {
                power = Some(resolve_value_with_context(value, ctx, effect.source));
            }
            Modification::SetToughness { value, .. } => {
                toughness = Some(resolve_value_with_context(value, ctx, effect.source));
            }
            Modification::SetPowerToughness {
                power: p,
                toughness: t,
                ..
            } => {
                power = Some(resolve_value_with_context(p, ctx, effect.source));
                toughness = Some(resolve_value_with_context(t, ctx, effect.source));
            }
            Modification::ModifyPower(delta) => {
                if let Some(ref mut p) = power {
                    *p += delta;
                }
            }
            Modification::ModifyToughness(delta) => {
                if let Some(ref mut t) = toughness {
                    *t += delta;
                }
            }
            Modification::ModifyPowerToughness {
                power: dp,
                toughness: dt,
            } => {
                if let Some(ref mut p) = power {
                    *p += dp;
                }
                if let Some(ref mut t) = toughness {
                    *t += dt;
                }
            }
            Modification::SwitchPowerToughness => {
                std::mem::swap(&mut power, &mut toughness);
            }
            _ => {}
        }
    }

    // If counters still haven't been applied (no 7c or 7d effects, or all 7c effects
    // had earlier timestamps), apply them now at the end of 7c
    if !counters_applied {
        apply_counter_modifications(object, &mut power, &mut toughness);
    }

    chars.power = power;
    chars.toughness = toughness;
}

/// Apply +1/+1 and -1/-1 counter modifications to power and toughness.
/// Per Rule 613.4c, these are part of sublayer 7c.
fn apply_counter_modifications(
    object: &Object,
    power: &mut Option<i32>,
    toughness: &mut Option<i32>,
) {
    let plus_counters = object
        .counters
        .get(&CounterType::PlusOnePlusOne)
        .copied()
        .unwrap_or(0) as i32;
    let minus_counters = object
        .counters
        .get(&CounterType::MinusOneMinusOne)
        .copied()
        .unwrap_or(0) as i32;

    if let Some(p) = power {
        *p += plus_counters - minus_counters;
    }
    if let Some(t) = toughness {
        *t += plus_counters - minus_counters;
    }
}

/// Check if an effect applies to a specific object.
///
/// Per Rules 611.2c and 611.3a:
/// - Resolution effects (from spells/abilities) only apply to locked targets
/// - Static ability effects apply to all objects matching their filter
fn effect_applies_to(
    effect: &ContinuousEffect,
    object: &Object,
    chars: &CalculatedCharacteristics,
    ctx: &CalculationContext,
) -> bool {
    // First, check if this is a Resolution effect with locked targets.
    // Per Rule 611.2c, these effects only apply to the specific targets
    // that were chosen when the spell or ability resolved.
    if let EffectSourceType::Resolution { ref locked_targets } = effect.source_type {
        // Resolution effects only apply to their locked targets
        if !locked_targets.contains(&object.id) {
            return false;
        }
        // If the object is in the locked targets, still verify it's on the battlefield
        // (the effect shouldn't apply if the target somehow left and returned)
        return object.zone == Zone::Battlefield;
    }

    // For StaticAbility, CharacteristicDefining, Combat, and Copy effects,
    // check the EffectTarget as normal (they apply dynamically).
    match &effect.applies_to {
        EffectTarget::Specific(id) => *id == object.id,
        EffectTarget::Source => effect.source == object.id,
        EffectTarget::AllPermanents => object.zone == Zone::Battlefield,
        EffectTarget::AllCreatures => {
            object.zone == Zone::Battlefield && chars.card_types.contains(&CardType::Creature)
        }
        EffectTarget::Filter(filter) => {
            // Check if object matches filter
            filter_matches(filter, object, chars, ctx)
        }
        EffectTarget::AttachedTo(source_id) => {
            // The effect applies to whatever permanent the source is attached to
            if let Some(source) = ctx.objects.get(source_id) {
                source.attached_to == Some(object.id) && object.zone == Zone::Battlefield
            } else {
                false
            }
        }
    }
}

/// Check if an object matches a filter (using calculated characteristics where available).
fn filter_matches(
    filter: &ObjectFilter,
    object: &Object,
    chars: &CalculatedCharacteristics,
    _ctx: &CalculationContext,
) -> bool {
    // Check zone
    if let Some(zone) = filter.zone
        && object.zone != zone
    {
        return false;
    }

    // Check card types (using calculated types)
    if !filter.card_types.is_empty()
        && !filter
            .card_types
            .iter()
            .any(|t| chars.card_types.contains(t))
    {
        return false;
    }

    // Check subtypes (using calculated subtypes)
    // Note: For creature type filters, ANY matching subtype is enough
    if !filter.subtypes.is_empty() && !filter.subtypes.iter().any(|t| chars.subtypes.contains(t)) {
        return false;
    }
    if filter
        .excluded_subtypes
        .iter()
        .any(|t| chars.subtypes.contains(t))
    {
        return false;
    }

    // Check controller
    if let Some(ref controller_filter) = filter.controller {
        use crate::filter::PlayerFilter;
        match controller_filter {
            PlayerFilter::You => {
                // "You" means the controller of the effect's source
                // For now, we can't easily determine this without more context
                // This is a simplification
            }
            PlayerFilter::Opponent => {
                // Similar issue
            }
            PlayerFilter::Specific(player_id) => {
                if chars.controller != *player_id {
                    return false;
                }
            }
            PlayerFilter::Any => {}
            // Other variants not applicable in this context
            _ => {}
        }
    }

    // Check colors (using calculated colors)
    if let Some(colors) = filter.colors
        && chars.colors.intersection(colors).is_empty()
    {
        return false;
    }

    // Check excluded supertypes (e.g., nonbasic lands for Blood Moon)
    if filter
        .excluded_supertypes
        .iter()
        .any(|t| chars.supertypes.contains(t))
    {
        return false;
    }

    true
}

/// Check if an object matches a filter using calculated characteristics and a known controller.
fn filter_matches_with_controller(
    filter: &ObjectFilter,
    object: &Object,
    chars: &CalculatedCharacteristics,
    game: &crate::game_state::GameState,
    effect_controller: PlayerId,
) -> bool {
    if let Some(zone) = filter.zone
        && object.zone != zone
    {
        return false;
    }

    if !filter.card_types.is_empty()
        && !filter
            .card_types
            .iter()
            .any(|t| chars.card_types.contains(t))
    {
        return false;
    }

    if filter
        .excluded_card_types
        .iter()
        .any(|t| chars.card_types.contains(t))
    {
        return false;
    }

    if !filter.subtypes.is_empty() && !filter.subtypes.iter().any(|t| chars.subtypes.contains(t)) {
        return false;
    }
    if filter
        .excluded_subtypes
        .iter()
        .any(|t| chars.subtypes.contains(t))
    {
        return false;
    }

    if !filter.supertypes.is_empty()
        && !filter
            .supertypes
            .iter()
            .any(|t| chars.supertypes.contains(t))
    {
        return false;
    }
    if filter
        .excluded_supertypes
        .iter()
        .any(|t| chars.supertypes.contains(t))
    {
        return false;
    }

    if let Some(ref controller_filter) = filter.controller {
        use crate::filter::PlayerFilter;
        match controller_filter {
            PlayerFilter::You => {
                if chars.controller != effect_controller {
                    return false;
                }
            }
            PlayerFilter::Opponent => {
                if chars.controller == effect_controller {
                    return false;
                }
            }
            PlayerFilter::Specific(player_id) => {
                if chars.controller != *player_id {
                    return false;
                }
            }
            PlayerFilter::Any => {}
            _ => {}
        }
    }

    if let Some(colors) = filter.colors
        && chars.colors.intersection(colors).is_empty()
    {
        return false;
    }

    if filter.colorless && !chars.colors.is_empty() {
        return false;
    }
    if filter.multicolored && chars.colors.count() < 2 {
        return false;
    }

    if filter.token && object.kind != crate::object::ObjectKind::Token {
        return false;
    }
    if filter.nontoken && object.kind == crate::object::ObjectKind::Token {
        return false;
    }

    let is_tapped = game.is_tapped(object.id);
    if filter.tapped && !is_tapped {
        return false;
    }
    if filter.untapped && is_tapped {
        return false;
    }

    if let Some(power_cmp) = &filter.power {
        if let Some(power) = chars.power {
            if !power_cmp.satisfies(power) {
                return false;
            }
        } else {
            return false;
        }
    }

    if let Some(toughness_cmp) = &filter.toughness {
        if let Some(toughness) = chars.toughness {
            if !toughness_cmp.satisfies(toughness) {
                return false;
            }
        } else {
            return false;
        }
    }

    if let Some(mv_cmp) = &filter.mana_value {
        let mv = object
            .mana_cost
            .as_ref()
            .map(|mc| mc.mana_value() as i32)
            .unwrap_or(0);
        if !mv_cmp.satisfies(mv) {
            return false;
        }
    }

    if filter.has_mana_cost {
        match &object.mana_cost {
            Some(mc) if !mc.is_empty() => {}
            _ => return false,
        }
    }

    if filter.no_x_in_cost
        && let Some(mc) = &object.mana_cost
        && mc.has_x()
    {
        return false;
    }

    if let Some(required_name) = &filter.name
        && object.name != *required_name
    {
        return false;
    }

    if filter.is_commander && !game.commanders.contains(&object.id) {
        return false;
    }

    true
}

/// Resolve a Value to an i32 for continuous effect calculations.
///
/// This is used during layer system calculations where we have access to game objects
/// but not a full ExecutionContext. Handles common computed values like Count and SourcePower.
fn resolve_value_with_context(
    value: &Value,
    ctx: &CalculationContext<'_>,
    source: ObjectId,
) -> i32 {
    use crate::target::FilterContext;

    match value {
        Value::Fixed(n) => *n,

        Value::X => 0, // X is 0 unless specified (resolved at cast time, not layer time)

        Value::Count(filter) => {
            // Build a minimal filter context for the source's controller
            let controller = ctx
                .objects
                .get(&source)
                .map(|o| o.controller)
                .unwrap_or(crate::ids::PlayerId::from_index(0));

            let filter_ctx = FilterContext {
                you: Some(controller),
                source: Some(source),
                active_player: None,
                opponents: Vec::new(), // Would need game state for full resolution
                teammates: Vec::new(),
                defending_player: None,
                attacking_player: None,
                your_commanders: Vec::new(),
                iterated_player: None,
                target_players: Vec::new(),
                tagged_objects: std::collections::HashMap::new(),
            };

            ctx.battlefield
                .iter()
                .filter_map(|&id| ctx.objects.get(&id))
                .filter(|obj| filter.matches(obj, &filter_ctx, ctx.game))
                .count() as i32
        }

        Value::SourcePower => ctx
            .objects
            .get(&source)
            .and_then(|o| o.power())
            .unwrap_or(0),

        Value::SourceToughness => ctx
            .objects
            .get(&source)
            .and_then(|o| o.toughness())
            .unwrap_or(0),

        Value::CountersOnSource(counter_type) => ctx
            .objects
            .get(&source)
            .map(|o| o.counters.get(counter_type).copied().unwrap_or(0) as i32)
            .unwrap_or(0),

        // For these, we'd need more complex resolution (game state, execution context)
        // Return 0 as fallback (these are rare in continuous effects anyway)
        Value::XTimes(_)
        | Value::CountPlayers(_)
        | Value::CountersOn(_, _)
        | Value::PowerOf(_)
        | Value::ToughnessOf(_)
        | Value::LifeTotal(_)
        | Value::CardsInHand(_)
        | Value::CardsInGraveyard(_)
        | Value::SpellsCastThisTurn(_)
        | Value::SpellsCastBeforeThisTurn(_)
        | Value::CardTypesInGraveyard(_)
        | Value::EffectValue(_)
        | Value::WasKicked
        | Value::WasBoughtBack
        | Value::WasEntwined
        | Value::WasPaid(_)
        | Value::WasPaidLabel(_)
        | Value::TimesPaidLabel(_)
        | Value::TimesPaid(_)
        | Value::KickCount
        | Value::TaggedCount => 0,
    }
}

fn build_layer_baseline(
    objects: &HashMap<ObjectId, Object>,
    effects: &[ContinuousEffect],
    battlefield: &[ObjectId],
    commanders: &HashSet<ObjectId>,
    game: &crate::game_state::GameState,
    layer: Layer,
    sublayer: Option<PtSublayer>,
) -> HashMap<ObjectId, CalculatedCharacteristics> {
    let filtered: Vec<ContinuousEffect> = effects
        .iter()
        .filter(|&effect| {
            let effect_layer = effect.modification.layer();
            if effect_layer < layer {
                return true;
            }

            if layer == Layer::PowerToughness
                && effect_layer == Layer::PowerToughness
                && let Some(current_sublayer) = sublayer
            {
                return effect.modification.pt_sublayer() < Some(current_sublayer);
            }

            false
        })
        .cloned()
        .collect();

    let mut baseline = HashMap::new();
    for &id in objects.keys() {
        if let Some(chars) = calculate_characteristics_with_effects_simple(
            id,
            objects,
            &filtered,
            battlefield,
            commanders,
            game,
        ) {
            baseline.insert(id, chars);
        }
    }

    baseline
}

/// Extract static abilities from a list of abilities.
fn extract_static_abilities(abilities: &[Ability]) -> Vec<StaticAbility> {
    abilities
        .iter()
        .filter_map(|a| {
            if let AbilityKind::Static(s) = &a.kind {
                Some(s.clone())
            } else {
                None
            }
        })
        .collect()
}

/// Add abilities from ability-granting counters (deathtouch counter, flying counter, etc.).
///
/// Per MTG rules, counters like "deathtouch counter" grant the ability to the permanent.
/// This is different from +1/+1 counters which modify P/T directly.
fn add_abilities_from_counters(object: &Object, chars: &mut CalculatedCharacteristics) {
    use crate::static_abilities::StaticAbilityId;

    for (&counter_type, &count) in &object.counters {
        if count == 0 {
            continue;
        }

        // Check if this counter grants an ability
        if let Some(ability_id) = counter_type.granted_ability() {
            // Check if we already have this ability (avoid duplicates)
            let already_has = chars.static_abilities.iter().any(|a| a.id() == ability_id);
            if already_has {
                continue;
            }

            // Add the appropriate static ability based on the counter type
            let ability: Option<StaticAbility> = match ability_id {
                StaticAbilityId::Deathtouch => Some(StaticAbility::deathtouch()),
                StaticAbilityId::Flying => Some(StaticAbility::flying()),
                StaticAbilityId::FirstStrike => Some(StaticAbility::first_strike()),
                StaticAbilityId::DoubleStrike => Some(StaticAbility::double_strike()),
                StaticAbilityId::Hexproof => Some(StaticAbility::hexproof()),
                StaticAbilityId::Indestructible => Some(StaticAbility::indestructible()),
                StaticAbilityId::Lifelink => Some(StaticAbility::lifelink()),
                StaticAbilityId::Menace => Some(StaticAbility::menace()),
                StaticAbilityId::Reach => Some(StaticAbility::reach()),
                StaticAbilityId::Trample => Some(StaticAbility::trample()),
                StaticAbilityId::Vigilance => Some(StaticAbility::vigilance()),
                StaticAbilityId::Haste => Some(StaticAbility::haste()),
                _ => None,
            };

            if let Some(sa) = ability {
                chars.static_abilities.push(sa);
            }
        }
    }
}

/// Get P/T override from level abilities if applicable.
fn get_level_ability_pt(object: &Object) -> Option<(i32, i32)> {
    let level_count = object
        .counters
        .get(&CounterType::Level)
        .copied()
        .unwrap_or(0);

    for ability in &object.abilities {
        if let AbilityKind::Static(s) = &ability.kind
            && let Some(levels) = s.level_abilities()
        {
            // Find the matching tier (highest tier that applies)
            for tier in levels.iter().rev() {
                if tier.applies_at_level(level_count) {
                    return tier.power_toughness;
                }
            }
        }
    }
    None
}

/// Get abilities granted by the current level tier.
fn get_level_granted_abilities(object: &Object) -> Vec<StaticAbility> {
    let level_count = object
        .counters
        .get(&CounterType::Level)
        .copied()
        .unwrap_or(0);

    for ability in &object.abilities {
        if let AbilityKind::Static(s) = &ability.kind
            && let Some(levels) = s.level_abilities()
        {
            // Find the matching tier
            for tier in levels.iter().rev() {
                if tier.applies_at_level(level_count) {
                    // Abilities are now stored as the new type directly
                    return tier.abilities.clone();
                }
            }
        }
    }
    Vec::new()
}

#[cfg(test)]
mod tests {
    use super::*;
    // Tests use the new StaticAbility type (already imported as StaticAbility in the module)

    #[test]
    fn test_layer_ordering() {
        assert!(Layer::Copy < Layer::Control);
        assert!(Layer::Control < Layer::Text);
        assert!(Layer::Text < Layer::Type);
        assert!(Layer::Type < Layer::Color);
        assert!(Layer::Color < Layer::Ability);
        assert!(Layer::Ability < Layer::PowerToughness);
    }

    #[test]
    fn test_pt_sublayer_ordering() {
        // Per Rule 613.4, counters are part of 7c (Modifying), not a separate sublayer
        assert!(PtSublayer::CharacteristicDefining < PtSublayer::Setting);
        assert!(PtSublayer::Setting < PtSublayer::Modifying);
        assert!(PtSublayer::Modifying < PtSublayer::Switching);
        // There is no separate Counters sublayer - they're applied within Modifying
    }

    #[test]
    fn test_modification_layer() {
        assert_eq!(
            Modification::CopyOf(ObjectId::from_raw(1)).layer(),
            Layer::Copy
        );
        assert_eq!(
            Modification::ChangeController(PlayerId::from_index(0)).layer(),
            Layer::Control
        );
        assert_eq!(
            Modification::AddCardTypes(vec![CardType::Creature]).layer(),
            Layer::Type
        );
        assert_eq!(
            Modification::AddColors(ColorSet::WHITE).layer(),
            Layer::Color
        );
        assert_eq!(
            Modification::AddAbility(StaticAbility::flying()).layer(),
            Layer::Ability
        );
        assert_eq!(
            Modification::ModifyPowerToughness {
                power: 2,
                toughness: 2
            }
            .layer(),
            Layer::PowerToughness
        );
    }

    #[test]
    fn test_effect_manager() {
        let mut manager = ContinuousEffectManager::new();

        let effect1 = ContinuousEffect::pump(
            ObjectId::from_raw(1),
            PlayerId::from_index(0),
            ObjectId::from_raw(2),
            2,
            2,
            Until::EndOfTurn,
        );

        let effect2 = ContinuousEffect::grant_ability(
            ObjectId::from_raw(1),
            PlayerId::from_index(0),
            ObjectId::from_raw(2),
            StaticAbility::flying(),
            Until::EndOfTurn,
        );

        let id1 = manager.add_effect(effect1);
        let _id2 = manager.add_effect(effect2);

        assert_eq!(manager.effects_sorted().len(), 2);

        // Effects should be sorted by layer
        let sorted = manager.effects_sorted();
        assert_eq!(sorted[0].modification.layer(), Layer::Ability);
        assert_eq!(sorted[1].modification.layer(), Layer::PowerToughness);

        // Remove one effect
        manager.remove_effect(id1);
        assert_eq!(manager.effects_sorted().len(), 1);

        // Remaining effect should be the ability grant
        assert!(matches!(
            manager.effects_sorted()[0].modification,
            Modification::AddAbility(_)
        ));
    }

    #[test]
    fn test_end_of_turn_cleanup() {
        let mut manager = ContinuousEffectManager::new();

        // Add a permanent effect
        let permanent = ContinuousEffect::new(
            ObjectId::from_raw(1),
            PlayerId::from_index(0),
            EffectTarget::AllCreatures,
            Modification::ModifyPowerToughness {
                power: 1,
                toughness: 1,
            },
        );

        // Add an until-end-of-turn effect
        let temporary = ContinuousEffect::pump(
            ObjectId::from_raw(2),
            PlayerId::from_index(0),
            ObjectId::from_raw(3),
            3,
            3,
            Until::EndOfTurn,
        );

        manager.add_effect(permanent);
        manager.add_effect(temporary);

        assert_eq!(manager.effects_sorted().len(), 2);

        manager.cleanup_end_of_turn();

        assert_eq!(manager.effects_sorted().len(), 1);
        assert!(matches!(
            manager.effects_sorted()[0].duration,
            Until::Forever
        ));
    }

    #[test]
    fn test_timestamp_ordering() {
        let mut manager = ContinuousEffectManager::new();

        // Add two effects in the same layer
        let effect1 = ContinuousEffect::new(
            ObjectId::from_raw(1),
            PlayerId::from_index(0),
            EffectTarget::Specific(ObjectId::from_raw(10)),
            Modification::SetColors(ColorSet::WHITE),
        );

        manager.advance_timestamp(); // Force different timestamps

        let effect2 = ContinuousEffect::new(
            ObjectId::from_raw(2),
            PlayerId::from_index(0),
            EffectTarget::Specific(ObjectId::from_raw(10)),
            Modification::SetColors(ColorSet::BLACK),
        );

        manager.add_effect(effect1);
        manager.add_effect(effect2);

        let sorted = manager.effects_sorted();
        assert_eq!(sorted.len(), 2);

        // Earlier timestamp should come first
        assert!(sorted[0].timestamp < sorted[1].timestamp);
    }

    #[test]
    fn test_ability_granting_counters() {
        use crate::static_abilities::StaticAbilityId;

        // Create a creature token with a deathtouch counter
        let mut creature = Object::new_token(
            ObjectId::from_raw(1),
            PlayerId::from_index(0),
            "Test Creature".to_string(),
            vec![CardType::Creature],
            Vec::new(),
            Some(2),
            Some(2),
            ColorSet::GREEN,
        );
        creature.add_counters(CounterType::Deathtouch, 1);

        // Calculate characteristics
        let mut chars = CalculatedCharacteristics {
            power: creature.base_power.as_ref().map(|p| p.base_value()),
            toughness: creature.base_toughness.as_ref().map(|t| t.base_value()),
            card_types: creature.card_types.clone(),
            subtypes: creature.subtypes.clone(),
            supertypes: creature.supertypes.clone(),
            colors: creature.colors(),
            abilities: creature.abilities.clone(),
            static_abilities: extract_static_abilities(&creature.abilities),
            controller: creature.controller,
        };

        // Add abilities from counters
        add_abilities_from_counters(&creature, &mut chars);

        // Should have deathtouch ability
        assert!(
            chars
                .static_abilities
                .iter()
                .any(|a| a.id() == StaticAbilityId::Deathtouch),
            "Creature with deathtouch counter should have deathtouch ability"
        );
    }

    #[test]
    fn test_multiple_ability_counters() {
        use crate::static_abilities::StaticAbilityId;

        // Create a creature token with multiple ability counters
        let mut creature = Object::new_token(
            ObjectId::from_raw(1),
            PlayerId::from_index(0),
            "Test Creature".to_string(),
            vec![CardType::Creature],
            Vec::new(),
            Some(2),
            Some(2),
            ColorSet::GREEN,
        );
        creature.add_counters(CounterType::Flying, 1);
        creature.add_counters(CounterType::Trample, 1);
        creature.add_counters(CounterType::Vigilance, 1);

        let mut chars = CalculatedCharacteristics {
            power: None,
            toughness: None,
            card_types: creature.card_types.clone(),
            subtypes: Vec::new(),
            supertypes: Vec::new(),
            colors: ColorSet::COLORLESS,
            abilities: Vec::new(),
            static_abilities: Vec::new(),
            controller: creature.controller,
        };

        add_abilities_from_counters(&creature, &mut chars);

        // Should have all three abilities
        assert!(
            chars
                .static_abilities
                .iter()
                .any(|a| a.id() == StaticAbilityId::Flying)
        );
        assert!(
            chars
                .static_abilities
                .iter()
                .any(|a| a.id() == StaticAbilityId::Trample)
        );
        assert!(
            chars
                .static_abilities
                .iter()
                .any(|a| a.id() == StaticAbilityId::Vigilance)
        );
        assert_eq!(chars.static_abilities.len(), 3);
    }

    #[test]
    fn test_no_duplicate_abilities_from_counters() {
        use crate::static_abilities::StaticAbilityId;

        // Create a creature token that already has flying
        let mut creature = Object::new_token(
            ObjectId::from_raw(1),
            PlayerId::from_index(0),
            "Test Creature".to_string(),
            vec![CardType::Creature],
            Vec::new(),
            Some(2),
            Some(2),
            ColorSet::GREEN,
        );
        creature.add_counters(CounterType::Flying, 1);

        // Start with flying ability already present
        let mut chars = CalculatedCharacteristics {
            power: None,
            toughness: None,
            card_types: creature.card_types.clone(),
            subtypes: Vec::new(),
            supertypes: Vec::new(),
            colors: ColorSet::COLORLESS,
            abilities: Vec::new(),
            static_abilities: vec![StaticAbility::flying()], // Already has flying
            controller: creature.controller,
        };

        add_abilities_from_counters(&creature, &mut chars);

        // Should still only have one flying ability (no duplicate)
        let flying_count = chars
            .static_abilities
            .iter()
            .filter(|a| a.id() == StaticAbilityId::Flying)
            .count();
        assert_eq!(flying_count, 1, "Should not add duplicate flying ability");
    }
}
